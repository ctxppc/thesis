# Intermediate Languages Supported by Glyco
**Glyco** is a nanopass compiler, so-called because it consists of numerous intermediate languages and small passes.

The pipeline, from high-level to low-level is:
{% for lang in types.typealiases where lang.name == "HighestSupportedLanguage" %}
{% include "Pipeline.stencil" %}
{% endfor %} ELF.

This document is generated automatically by [Sourcery](https://github.com/krzysztofzablocki/Sourcery) using GlycoKit's source files as input. To update it, go to `/Glyco/Sourcery` and invoke `sourcery --config Languages.yaml`. Pass the `--watch` flag to enable continuous updates.

## How to Use
Every intermediate language is defined by a context-free grammar, listed below. To write a program in some language, choose a production rule for that language's `Program` nonterminal (although often there's only one rule) and write a production that conforms to that rule. The rule mentions other nonterminals which are either defined in the same language are inherited from the lower language.

A rule mentioning a nonterminal in square brackets like `[Effect]` is satisfied with a sequence of zero or more productions of that nonterminal, with each such production separated by whitespace.

The nonterminal `String` is satisfied with a string such as `string` or `"long string"`. Quotation is required for strings that don't start with a letter (Unicode General Category L* and M*) or underscore (`_`), incl. the empty string. The nonterminal `Int` is satisfied with an integer literal such as `500` or `-12`. The nonterminal `Bool` is satisfied with either string literals `true` or `false`, optionally quoted.

A program written in some language `XY` should be stored in a file with extension `.xy` (case-insensitive) since Glyco uses the extension to determine the source language.

{% for lang in types.typealiases where lang.name == "HighestSupportedLanguage" %}
{% include "Grammar.stencil" %}
{% endfor %}