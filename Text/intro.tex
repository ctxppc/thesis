\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}}

\chapter{Introduction}
Sir Charles Antony Richard Hoare introduced null references in ALGOL in 1965 as a simple solution to implementing trees using pointers, something he reflected upon almost half a century later in \cite{null}:
\begin{quote}
	\enquote{That led me to suggest that the null pointer was a possible value of every reference variable […] and it may be perhaps a billion-dollar mistake.}
\end{quote}

Null pointers have over the decades caused numerous issues but are obviously not the only pointer-related problem. A whole class of memory safety issues are caused by incorrect handling of pointers. Buffer overflow attacks are possible when code doesn't properly check if a pointer points to memory appropriately allocated for the purpose. Some types of arbitrary code execution are possible when pointers are used to write executable code to memory which is later executed as part of normal program execution or another attack, like a shellcode attack.

A capability is, in the context of this thesis, a pointer that grants authority for a set of operations over a specific range of memory such as an array or object. Capability machines are processors that implement support for capabilities and more importantly efficiently enforce the invariants provided by them. When used properly, they can mitigate a wide class of memory safety problems and hence they have long been studied academically, e.g., a design for \emph{guarded pointers} to be implemented in hardware in \cite{guardedptrs}. Renewed interest has recently emerged in the form of a modern capability machine by \cite{intro2cheri}, Capability Hardware Enhanced RISC Instructions or \textbf{CHERI} for short, and the opportunities it presents for security features in high-level software abstractions. \Cref{ch:cheri} gives an overview of capabilities on CHERI.

This thesis explores a few of these high-level security features and provides an implementation for them on CHERI-RISC-V, an extension of the RISC-V instruction set architecture with support for CHERI capabilities. This implementation is in the form of a compiler implemented from scratch following a nanopass approach. This compiler, called \textbf{Glyco}, is designed, implemented, and evaluated in four stages.

The first version implements basic support for semi-functional programs with very limited capability-based security features. \Cref{ch:glyco} explores the nanopass approach, which is used in some educational and commercial compilers, then lays out the different parts of the first version of the Glyco compiler.

Capabilities enable the use of \textbf{secure \gs{cc}} which conform to a few desirable security properties around procedure calls and their local state. This thesis discusses \emph{\g{lse}}, a security property that guarantees that a procedure's local state is not accessible from other procedures or calls, and \emph{\g{wbcf}}, which ensures that called procedures return correctly to their caller. \Cref{ch:ghscc} presents this thesis' first contribution, a variant of a secure \g{cc} proposed by \cite{cerise} as well as its implementation in Glyco. We evaluate the nanopass approach by measuring the extension's impact on the compiler codebase and assess the impact of this \g{cc} on built programs by comparing them to a compilation with a more traditional \g{cc}.

A second contribution of this thesis is a feature we call \textbf{sealed objects}, which are similar to objects in object-oriented programming languages but with additional security properties. A sealed object's local state is only accessible from its methods and this is enforced at the hardware level with sealed capabilities. \Cref{ch:obj} examines the design and implementation of sealed objects as well as two additional features that are at the basis, namely \textbf{lambdas} and \textbf{named types}. We then evaluate the nanopass approach once again by quantifying the feature's impact on the compiler codebase.

A final contribution are \textbf{sealed closures}, which are anonymous functions that securely capture the environment they're defined in — the environment of a sealed closure cannot be modified after definition. Sealed closures rely on sealed objects and are thus a prime application for them. They are explored and the nanopass approach's impact on their implementation is evaluated in \cref{ch:cls}.

\paragraph{A note on versioning \& syntax} This thesis text presents a compiler in four iterations (or milestones), starting with a basic CHERI-RISC-V compiler with almost no security features built on capabilities (Glyco 0.1) and ending with a compiler featuring a secure \g{cc} (0.2), sealed objects (0.3), and sealed closures (1.0). One of the goals of this thesis is to explore how the nanopass approach performs for designing and implementing a compiler from scratch but also for extending it.

To present the reader with a consistent narrative, we have structured the text so that each chapter limits itself to the feature set and languages of the version being discussed. The first chapter discussing the compiler, \cref{ch:cheri}, introduces Glyco 0.1 while the following chapters extend this compiler. However, we have chosen to use the final syntax for examples across the text. The syntax of the discussed languages does not change significantly between versions and is of lesser importance to understanding the compiler and its evolution. A single syntax also allows the reader to readily try out the examples in the most refined version of the compiler.

A full grammar of the final compiler's different languages is presented in \cref{ch:grammar}.

\paragraph{Source code} The full source code as well as build \& usage instructions are available at \url{https://tsarouhas.eu/glyco/}.

\biblio{}
\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
