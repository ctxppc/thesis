\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}}

\chapter{Introduction}
Sir Charles Antony Richard Hoare introduced null references in ALGOL in 1965 as a simple solution to implementing trees using pointers, something he reflected upon almost half a century later in \cite{null}:
\begin{quote}
	\enquote{That led me to suggest that the null pointer was a possible value of every reference variable [â€¦] and it may be perhaps a billion-dollar mistake.}
\end{quote}

Null pointers have over the decades caused numerous issues but are obviously not the only pointer-related problem. A whole class of memory safety issues are caused by incorrect handling of pointers. Buffer overflow attacks are possible when code doesn't properly check if a pointer points to memory appropriately allocated for the purpose. Some types of arbitrary code execution are possible when pointers are used to write executable code to memory which is later executed as part of normal program execution or another attack, like a shellcode attack.

A capability is, in the context of this thesis, a pointer that grants authority for a set of operations over a specific range of memory such as an array or object. Capability machines are processors that implement support for capabilities and more importantly efficiently enforce the invariants provided by them. When used properly, they can mitigate a wide class of memory safety problems and hence they have long been studied academically, e.g., a design for \emph{guarded pointers} to be implemented in hardware in \cite{guardedptrs}. Renewed interest has recently emerged in the form of a modern capability machine by \cite{intro2cheri}, Capability Hardware Enhanced RISC Instructions or \textbf{CHERI} for short, and the opportunities it presents for security features in high-level software abstractions. \Cref{ch:cheri} gives an overview of capabilities on CHERI.

This thesis explores a few of these high-level security features and provides an implementation for them on CHERI-RISC-V, an extension of the RISC-V instruction set architecture with support for CHERI capabilities. This implementation is in the form of a compiler implemented from scratch following a nanopass approach. This compiler, called \textbf{Glyco}, is designed, implemented, and evaluated in three stages.

The first version implements basic support for semi-functional programs with very limited capability-based security features. \Cref{ch:glyco} explores the nanopass approach, which is used in some educational and commercial compilers, then lays out the different parts of the first version of the Glyco compiler.

Capabilities enable the use of secure \gs{cc} which conform to a few desirable security properties around procedure calls and their local state. This thesis discusses \g{lse}, a security property that guarantees that a procedure's local state is not accessible from other procedures or calls, and \g{wbcf}, which ensures that called procedures return correctly to their caller. \Cref{ch:ghscc} presents this thesis' first contribution, a variant of a secure \g{cc} proposed by \cite{cerise} as well as its implementation in Glyco. We evaluate the nanopass approach by measuring the extension's impact on the compiler codebase and assess the impact of this \g{cc} on built programs by comparing them to a compilation with a more traditional \g{cc}.

A second contribution of this thesis is a feature we call \textbf{sealed objects}, which are similar to objects in object-oriented programming languages but with additional security properties. A sealed object's local state is only accessible from its methods and this is enforced at the hardware level with sealed capabilities. \Cref{ch:obj} examines the design and implementation of sealed objects as well as two additional features that are at the basis, namely \textbf{lambdas} and \textbf{named types}. We then evaluate the nanopass approach once again by quantifying the feature's impact on the compiler codebase.

\biblio{}
\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
