\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}}

\chapter{Glyco}

Glyco\footnote{From the Greek term $\gamma\lambda\upsilon\kappa{}o$ meaning \enquote{sweet}, alluding to the taste of a wild cherry.} is a compiler targeting the CHERI-RISC-V architecture, producing software running on CheriBSD systems and on a Sail-based emulator of the CHERI-RISC-V ISA.

Glyco is built following a \emph{nanopass} compiler design, described by several authors in the context of compiler education \cite{:educomp} and commercial compiler development \cite{:commcomp}. A nanopass compiler consists of numerous small passes, so-called \emph{\nanopasses{}}, which translate one \emph{\il{}} to another. Source code is parsed into the compilerâ€™s first \il{}, which is then translated via \nanopasses{} through different \ils{}, ending up in the compiler's final \il{}. This final \il{} contains a string representation of the assembly code that is fed to LLVM for building \& linking an executable ELF file. This last step is unrelated to the research problem, hence this dependency on LLVM.

The nanopass design allows the compiler engineer to design and implement their compiler \emph{by iterated abstraction}. A simplified description follows. The engineer first chooses a target language (usually a machine language such as x86-64 or indeed CHERI-RISC-V) and determines an abstraction over it. The engineer then defines an \il{} that implements that abstraction as well as a \nanopass{} which transforms programs written in the new \il{} to the target language. The compiler engineer then repeats this process, this time abstracting over the \il{} with a new \il{} and \nanopass{}. This process goes on until a suitable level of abstraction has been achieved.

An important benefit of the nanopass approach is each new iteration begins and ends with a working compiler. After each iteration, users can start writing and compiling programs in the new \il{} and unit tests can be written that ensure that the new \nanopass{} produces the expected transformations. For experimental architectures such as CHERI-RISC-V, this also means that designers can experiment more quickly with new ideas, something that may be harder to do on a full-fledged production compiler such as the LLVM compiler toolchain.

Glyco currently defines 14 \ils{}. Each \il{} has a name and corresponding abbreviation, usually named after the abstraction it provides over the \lowerlang{}, and are defined by a context-free grammar. Starting from the lowest \il{}, these are:
\input{Language Summary}

Many of these \ils{} are adapted from an educational compiler in a compilers course targeting x86-64 systems, taught at Vrije Universiteit Brussel \cite{:compcourse} and University of British Columbia.

\section{From Assembly to Basic Blocks}

The first \il{}, named \emph{CHERI-RISC-V Assembly} (abbr. \emph{S}), is simply the CHERI-RISC-V assembly language and can be seen in \cref{bnf:s}, except for some linkage boilerplate that is added by the compiler just before passing it to LLVM.

\begin{figure}[ht]
	\begin{grammar}
		<Program> ::= (assembly: <String>)
	\end{grammar}
	\caption{The grammar for S.}
	\label{bnf:s}
\end{figure}

The second \il{}, named \emph{CHERI-RISC-V} (abbr. \emph{RV}), abstracts away from the textual nature of code by encoding each instruction in the language itself. An abridged grammar can be seen in \cref{bnf:rv}.

\begin{figure}[ht]
	\begin{grammar}
		
		<Program> ::= (instructions: <Instructions>)
		
		<Instructions> ::= <Instruction> | <Instruction> <Instructions>
		
		<Instruction> ::= copy(<DataType>, destination: <Register>, source: <Register>)
			\alt registerRegister(operation: <BinaryOperator>, rd: <Register>, rs1: <Register>, rs2: <Register>)
			\alt registerImmediate(operation: <BinaryOperator>, rd: <Register>, rs1: <Register>, imm: <Int>)
			\alt loadWord(destination: <Register>, address: <Register>)
			\alt storeWord(source: <Register>, address: <Register>)
			\alt offsetCapability(destination: <Register>, source: <Register>, offset: <Register>)
			\alt branch(rs1: <Register>, relation: <BranchRelation>, rs2: <Register>, target: <Label>)
			\alt jump(target: <Label>)
			\alt call(target: <Label>)
			\alt return
			\alt labelled(<Label>, <Instruction>)
			\alt $\cdots$
			
		<Register> ::= zero | ra | sp | gp | tp | t0 | t1 | t2 | fp | s1 | a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | s10 | s11 | t3 | t4 | t5 | t6
		
	\end{grammar}
	\caption{Abridged grammar for RV.}
	\label{bnf:rv}
\end{figure}

The next \il{} introduces the call frame, hence its name \emph{Frame Locations} (abbr. \emph{FL}), and restricts memory operations to either memory operations on the call frame or memory operations on statically allocated arrays. An abridged grammar is shown in \cref{bnf:fl}. FL reserves the register \texttt{t0} to perform the necessary capability offset operations; register \texttt{t0} is therefore no longer available at this level of abstraction.

\begin{figure}[ht]
	\begin{grammar}
		
		<Program> ::= (<Effects>)
		
		<Effects> ::= <Effect> | <Effect> <Effects>
		
		<Effect> ::= copy(<DataType>, into: <Register>, from: <Register>)
			\alt compute(into: <Register>, value: <BinaryExpression>)
			\alt load(<DataType>, into: <Register>, from: <Frame.Location>)
			\alt store(<DataType>, into: <Frame.Location>, from: <Register>)
			\alt loadElement(<DataType>, into: <Register>, vector: <Register>, index: <Register>)
			\alt storeElement(<DataType>, vector: <Register>, index: <Register>, from: <Register>)
			\alt branch(to: <Label>, <Register>, <BranchRelation>, <Register>)
			\alt jump(to: <Label>)
			\alt call(<Label>)
			\alt return
			\alt labelled(<Label>, <Effect>)
			
		<Register> ::= zero | ra | sp | gp | tp | t1 | t2 | fp | s1 | a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | s10 | s11 | t3 | t4 | t5 | t6
		
	\end{grammar}
	\caption{Abridged grammar for FL.}
	\label{bnf:fl}
\end{figure}

% TODO

\biblio{}
\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
