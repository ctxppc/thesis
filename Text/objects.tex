\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}}

\chapter{Sealed Objects}
The previous chapter discussed a first extension of the Glyco compiler, namely a secure calling convention. This chapter treats a second extension, a feature we call \emph{sealed objects}.

Sealed objects depend on two new features; we begin by defining lambdas in \cref{sct:lambda} and named \& nominal types in \cref{sct:named-ty} before defining the semantics of objects and methods in \cref{sct:obj-meth}. We then list in \cref{sct:obj-sec} a few security properties afforded by sealed objects. We finish this chapter by outlining the changes to the compiler in \cref{sct:obj-changes} and evaluating sealed objects in \cref{sct:obj-eval}.

This chapter discusses the feature set and languages of Glyco 1.0.\footnote{The source code is available at \url{https://tsarouhas.eu/glyco/1.0/}.} A full language reference can be found in \cref{ch:grammar}.

\section{Lambdas} \label{sct:lambda}
A first addition to Glyco is the \textbf{lambda}, i.e., an anonymous function, in a new \g{il} called \textbf{Λ} (Lambdas) above EX. Lambdas allow the programmer to define functions (\texttt{λ} values) at the point of use and to pass them around as values. For example, the following Λ program defines a lambda that computes the sum of its two parameters and immediately applies it on $1080$ and $-80$.
\ilfile{Programs/sum.l}

\paragraph{From Λ to EX} The \g{nanopass} from Λ to EX extracts the functions defined by \texttt{λ} values into the global scope (with an auto-generated name) and replaces the \texttt{λ} values by code capabilities to those functions. The above program is thus \lowered{} to the EX program
\ilfile{Programs/sum.ex}

\section{Alias \& Nominal Types} \label{sct:named-ty}
A second new feature is support for defining new (named) types in a new \g{il} \textbf{NT} (Named Types) above Λ. A value in NT can be
\begin{itemize}[nosep]
	\item an (8-bit) byte, a \iil/u8/;
	\item a (32-bit) signed integer, an \iil/s32/;
	\item a capability to a vector of \iil/T/s, a \iil/cap(vector(T, sealed: S))/;
	\item a capability to a record, a \iil/cap(record((name, Type) …, sealed: S))/;
	\item a capability to a function, a \iil/cap(function(takes: p …, returns: r))/;
	\item a \g{sealcap}, a \iil/cap(seal(sealed: S))/; or
	\item a value of a type named \iil/T/
\end{itemize}
where \iil/S/ is \iil/true/ if the capability is sealed and \iil/false/ otherwise. A type can be defined using a \textbf{\texttt{letType} value} in one of two ways.

\paragraph{Alias types} An \textbf{alias type definition} creates an \textbf{alias type}, a type that is equivalent to the type it's defined as. An alias type can have a shorter or semantically meaningful type name that the type it's defined as.

For instance, the following NT program defines an alias type named \iil/Sequence/ and uses it in a simple computation that evaluates to 4. The value \iil/pi/ created by \iil/vector(s32, count: 3)/ is typed \iil/cap(vector(s32, sealed: false))/ but is accepted by the function which takes an argument typed \iil/Sequence/.
\ilfile{Programs/alias.nt}

\paragraph{Nominal types} A \textbf{nominal type definition} creates a \textbf{nominal type}, a type which is only equivalent to itself. A nominal type is effectively a new type by itself and can be used to ensure that two representationally identical but semantically different types of values cannot accidentally be mixed. However, a value can be explicitly \texttt{cast}ed to a value of a different type that has the same representation.

For example, the following NT program defines two nominal types \iil/Kelvin/ and \iil/Celsius/ and uses them to convert 500 °C to K and back to °C.
\ilfile{Programs/temp.nt}

However, the following program is not valid since the second invocation of \iil/toCelsius/, which excepts a value in \iil/Kelvin/, is given a value in \iil/Celsius/. Nominal type rules prevent the accidental conversion from \iil/Kelvin/ to \iil/Celsius/, even though both types are represented by \iil/s32/.
\ilfile{Programs/tempbad.nt}

\begin{quote}
	\ttfamily\footnotesize
	Error: \iil/evaluate(toCelsius, 500)/ is of type \iil/named(Celsius)/ and thus cannot be used for \iil/(k, Kelvin, sealed: false)/
\end{quote}

\paragraph{Implicit type casts} With some exceptions, the type checker rejects any uses of values of a structural type such as \iil/s32/ in contexts where a nominal type is expected and vice versa. This restriction can be bypassed using a \texttt{cast}. For ergonomic reasons, the type-checker performs an implicit cast on
\begin{itemize}[nosep]
	\item an argument of structural type that is passed to a parameter of nominal type, like in \iil/evaluate(toKelvin, 500)/ above;
	\item a record value of nominal type in a \texttt{field} value;
	\item a vector value of nominal type in an \texttt{element} value;
	\item a seal value of nominal type in a \texttt{sealed} value;
	\item an operand of structural type in a \texttt{binary} value when the other operand is of nominal type — the result of the \texttt{binary} value is of nominal type;
	\item a function's or lambda's result value of structural type when the result type is nominal; and
	\item a program's result value of nominal type (to \iil/s32/), like the result in \iil/Celsius/ above.
\end{itemize}

\paragraph{From NT to Λ} The \g{nanopass} from NT to Λ replaces named types by their Λ equivalents and checks if the nominal typing rules hold.

\section{Objects \& Methods} \label{sct:obj-meth}
A \textbf{sealed object} (or simply \textbf{object} in this chapter) is an encapsulated record on which a predefined set of functions can operate. These functions are the object's \textbf{methods}.

An object belongs to an \textbf{object type}, which determines the record type and methods of all objects of that type. Sealed objects in Glyco are in this respect similar to objects in object-oriented programming languages such as Java. Object types however do not support inheritance and record fields cannot be made visible outside of methods.

Object types can be defined using an \textbf{object type definition} in a \texttt{letType} value.

The following OB program implements a \texttt{Counter} object type, creates a counter with an initial value of 32, increases the count three times, and evaluates to the counter's final value (35):
\ilfile{Programs/counter.ob}

An object type consists of three parts:
\begin{itemize}
    \item A \textbf{name}, which is \iil/Counter/ in the previous example.
\end{itemize}

An object in Glyco is represented as a sealed capability to a record.

\subsection{Object Types are Objects}
% TODO

\section{Object State Encapsulation} \label{sct:obj-sec}
% TODO

\section{Changes to Glyco} \label{sct:obj-changes}
% TODO

\section{Evaluation} \label{sct:obj-eval}
% TODO

% \biblio{} TODO: Uncomment after adding a citation in chapter.
\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
