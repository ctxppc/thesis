\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}}

\chapter{Sealed Objects} \label{ch:obj}
The previous chapter discussed a first extension of the Glyco compiler, namely a secure calling convention. This chapter treats a second extension, a feature we call \emph{sealed objects}.

Sealed objects depend on two new features; we begin hence by describing lambdas in \cref{sct:lambda} and named \& nominal types in \cref{sct:named-ty} before defining the semantics of objects and methods in \cref{sct:obj-meth}. We then list in \cref{sct:obj-sec} a few security properties afforded by sealed objects. We finish this chapter by outlining the changes to the compiler in \cref{sct:obj-changes} and evaluating sealed objects in \cref{sct:obj-eval}.

This chapter discusses the feature set and languages of Glyco 1.0.\footnote{The source code is available at \url{https://tsarouhas.eu/glyco/1.0/}.} A full language reference can be found in \cref{ch:grammar}.

\section{Lambdas} \label{sct:lambda}
A first addition to Glyco is the \textbf{lambda}, i.e., an anonymous function, in a new \g{il} called \textbf{Λ} (Lambdas) above EX. Lambdas allow the programmer to define functions (\texttt{λ} values) at the point of use and to pass them around as values. For example, the following Λ program defines a lambda that computes the sum of its two parameters and immediately applies it on $1080$ and $-80$.
\ilfile{Programs/sum.l}

The scope of a lambda definition extends beyond the \texttt{λ} value itself to the \texttt{let} value defining it, in a similar way to \texttt{letRec} values in some functional programming languages and unlike definitions of other kinds of values. This enables mutual recursion such as the following (inefficient) program determining the parity of 420.
\ilfile{Programs/evenodd.l}

Finally, since \texttt{λ} values with support for mutual recursion provide the same expressive power as programs with global functions, Λ removes support for global functions. The reader should bear in mind however that lambdas do not \emph{increase} the expressive power of programs but merely make it easier to define functions. Lambda values evaluate to code capabilities and do not carry an environment, i.e., lambdas in Λ aren't closures.

\paragraph{From Λ to EX} The \g{nanopass} from Λ to EX extracts the functions defined by \texttt{λ} values into the global scope (with either an auto-generated name or a name derived from the lambda definition) and replaces the \texttt{λ} values by code capabilities to those functions. The first program of this chapter is thus \lowered{} to the EX program
\ilfile{Programs/sum.ex}

The \g{nanopass} injects lambda definitions, i.e., λ values in a \texttt{let} value, in the lambda body to enable (mutual) recursion. The parity program above is thus \lowered{} as
\ilfile{Programs/evenodd.ex}

\section{Alias \& Nominal Types} \label{sct:named-ty}
A second new feature is support for defining new (named) types in a new \g{il} \textbf{NT} (Named Types) above Λ. A value in NT can be
\begin{itemize}[nosep]
	\item an (8-bit) byte, a \iil/u8/;
	\item a (32-bit) signed integer, an \iil/s32/;
	\item a capability to a vector of \iil/T/s, a \iil/cap(vector(T, sealed: S))/;
	\item a capability to a record, a \iil/cap(record((name, Type) …, sealed: S))/;
	\item a capability to a function, a \iil/cap(function(takes: p …, returns: r))/;
	\item a \g{sealcap}, a \iil/cap(seal(sealed: S))/; or
	\item a value of a type named \iil/T/
\end{itemize}
where \iil/S/ is \iil/true/ if the capability is sealed and \iil/false/ otherwise. A type can be defined using a \textbf{\texttt{letType} value} in one of two ways.

\paragraph{Alias types} An \textbf{alias type definition} creates an \textbf{alias type}, a type that is equivalent to the type it's defined as. An alias type can have a shorter or semantically meaningful type name that the type it's defined as.

For instance, the following NT program defines an alias type named \iil/Sequence/ and uses it in a simple computation that evaluates to 4. The value \iil/pi/ created by \iil/vector(s32, count: 3)/ is typed \iil/cap(vector(s32, sealed: false))/ but is accepted by the function which takes an argument typed \iil/Sequence/.
\ilfile{Programs/alias.nt}

\paragraph{Nominal types} A \textbf{nominal type definition} creates a \textbf{nominal type}, a type which is only equivalent to itself. A nominal type is effectively a new type by itself and can be used to ensure that two representationally identical but semantically different types of values cannot accidentally be mixed. However, a value can be explicitly \texttt{cast}ed to a value of a different type that has the same representation.

For example, the following NT program defines two nominal types \iil/Kelvin/ and \iil/Celsius/ and uses them to convert 500 °C to K and back to °C.
\ilfile{Programs/temp.nt}

However, the following program is not valid since the second invocation of \iil/toCelsius/, which excepts a value in \iil/Kelvin/, is given a value in \iil/Celsius/. Nominal type rules prevent the accidental conversion from \iil/Kelvin/ to \iil/Celsius/, even though both types are represented by \iil/s32/.
\ilfile{Programs/tempbad.nt}

\begin{quote}
	\ttfamily\footnotesize
	Error: \iil/evaluate(toCelsius, 500)/ is of type \iil/named(Celsius)/ and thus cannot be used for \iil/(k, Kelvin, sealed: false)/
\end{quote}

\paragraph{Implicit type casts} With some exceptions, the type checker rejects any uses of values of a structural type such as \iil/s32/ in contexts where a nominal type is expected and vice versa. This restriction can be bypassed using a \texttt{cast}. For ergonomic reasons, the type-checker performs an implicit cast on
\begin{itemize}[nosep]
	\item an argument of structural type that is passed to a parameter of nominal type, like in \iil/evaluate(toKelvin, 500)/ above;
	\item a record value of nominal type in a \texttt{field} value;
	\item a vector value of nominal type in an \texttt{element} value;
	\item a seal value of nominal type in a \texttt{sealed} value;
	\item an operand of structural type in a \texttt{binary} value when the other operand is of nominal type — the result of the \texttt{binary} value is of nominal type;
	\item a lambda's result value of structural type when the result type is nominal; and
	\item a program's result value of nominal type (to \iil/s32/), like the result in \iil/Celsius/ above.
\end{itemize}

\paragraph{From NT to Λ} The \g{nanopass} from NT to Λ replaces named types by their Λ equivalents and checks if the nominal typing rules hold.

\section{Objects \& Methods} \label{sct:obj-meth}
A \textbf{sealed object} (or simply \textbf{object} in this chapter) is an encapsulated record on which a predefined set of functions can operate. These functions are the object's \textbf{\gs{method}}.

An object belongs to an \textbf{object type}, which determines the record type and \gs{method} of all objects of that type. Sealed objects in Glyco are in this respect similar to objects in object-oriented programming languages such as Java. Object types however do not support inheritance and record fields cannot be made visible outside of \gs{method}.

Object types can be defined using an \textbf{object type definition} in a \texttt{letType} value. A definition consists of
\begin{itemize}[nosep]
	\item a name, like any other type definition;
	\item a record type specifying the structure of each object's state;
	\item an initialiser effect applied on all new objects accepting zero or more parameters; and
	\item zero or more \gs{method}.
\end{itemize}

An \textbf{\g{init}} is a pseudo-\g{method} automatically invoked on every new object immediately after its state is allocated that ensures that the object has the right initial state. An object can be created using an \texttt{object} value, which accepts a type name and arguments to the initialiser's parameters. \Gs{method} can only be defined when the object type is being defined. They can be invoked using a \texttt{message} value, which takes an object, \g{method} name, and arguments to the \g{method}'s parameters. Initialisers and \gs{method} alike get a capability to the object's state, i.e., the record composing it, through the \iil/self/ value.

The following OB program implements the object type \iil/Counter/, creates a counter with an initial value of 32, increases the count three times, and evaluates to the counter's final value (35):
\ilfile{Programs/counter.ob}

\subsection{Object State Encapsulation \& Unique Seals} \label{sct:obj-sec}
The first important security property afforded by sealed objects is that an object's state is \textbf{only accessible within the \g{init} or a \g{method} defined during object type definition} in \texttt{letType}.\footnote{This property does not hold if the \g{init} or a \g{method} leaks an unsealed capability to the state record. Our threat model assumes trust in an object type's implementation.} A second security property is that a \g{method} or \g{init} \textbf{can only be invoked on an object of the type defining that \g{method} or \g{init}}.\footnote{This property similarly does not hold if an unsealed code capability to the \g{method} is leaked by the type owner.}

Both properties are achieved by \g{sealing} capabilities to objects and \gs{method} using unique \gs{sealcap} provided by a \g{rtrt}. \G{sealing} capabilities using a \g{sealcap} is a power which was originally bestowed upon the \g{rt} in the design and implementation of \g{ghscc} where an \g{scall} seals a return–frame capability pair before passing control to the callee.

An \textbf{\g{objcap}} is a sealed capability to a record embodying an object. A \textbf{\g{methcap}} is a sealed code capability to a \g{method}. Due to their sealed nature, \gs{objcap} cannot be used in an \texttt{getField} value or \texttt{setField} effect and similarly \gs{methcap} cannot be used in an \texttt{evaluate} value without a receiver of the right object type.\footnote{A \texttt{getField} value is eventually \lowered{} to a load instruction in the CHERI-RISC-V language. A \texttt{setField} effect is eventually \lowered{} to a store instruction. An \texttt{evaluate} value is eventually \lowered{} to either a \texttt{CJALR} or \texttt{CInvoke} instruction. Loading or storing using a sealed capability, jumping to a sealed code capability using \texttt{CJALR}, or invoking a mismatched code–data capability pair using \texttt{CInvoke} results in a machine trap.}

Object and method capabilities belonging to the same object type are sealed using the same \g{sealcap}; a \g{methcap} can therefore be invoked on an \g{objcap} using the \texttt{CInvoke} CHERI-RISC-V instruction. A \g{methcap} cannot be invoked on an \g{objcap} belonging to a different object type; the hardware ensures this invariant when the \texttt{CInvoke} instruction is executed, with a violation causing a machine trap.

\subsection{Object Types Are Objects}
When an object type is defined in a \texttt{letType} value, a unique \g{sealcap} is created and used for sealing the new type's \gs{methcap}. This capability must be protected from adversaries as it allows for additional methods to be defined. With access to the \g{sealcap}, the adversary merely needs to seal a \g{methcap} of its own and invoke the adversarial method on the sealed object to get access to the object's state, thereby breaking the encapsulation property.

An object type's \g{sealcap} is also needed for sealing new \gs{objcap}, i.e., for creating new objects of the object type. To allow an adversary to create new objects of a type it doesn't own, Glyco introduces the concept of an \textbf{object type object}, an object representing an object type, and the notion of a \textbf{metatype}, the type of a type object. The metatype provides a \texttt{createObject} method with the same parameters as those of the type's \g{init} and which produces an \g{objcap}. The \g{sealcap} needed for \g{sealing} the capability to the initialised state of the new object is stored within the type object and only accessible from within the \texttt{createObject} method by relying on the security properties afforded by objects.

Each object type has an associated type object and metatype. The metatype (the type object's type) doesn't define an \g{init}; instead, the singleton type object's state is statically allocated and initialised at the point of the object type definition and the metatype's \g{sealcap} is discarded after use.

\subsection{\G{lowering} OB to NT}
We'll work through the OB to NT \g{nanopass} by applying it on the \iil/Counter/ example at the beginning of this section.
\ilfile[lastline=2]{Programs/counter.nt}

An object type definition (in a \texttt{letType}) is \lowered{} to NT by
\begin{enumerate}[nosep]
	
	\item defining a nominal type definition;
	\ilfile[firstline=3, lastline=5]{Programs/counter.nt}
	
	\item creating unique \gs{sealcap} for the metatype and the new type;
	\ilfile[firstline=6, lastline=7]{Programs/counter.nt}
	
	\item allocating and initialising a type object with the type's \g{sealcap};
	\item sealing the capability to this object with the metatype's \g{sealcap};
	\ilfile[firstline=8, lastline=17]{Programs/counter.nt}
	
	\item implementing the metatype's \texttt{createObject} method using a lambda that allocates a state record, executes the initialiser's effect, seals a capability to the state record using the \g{sealcap} stored in the type object, and returns this sealed capability to the method's caller;
	\item sealing the capability for this method with the metatype's \g{sealcap};
	\ilfile[firstline=18, lastline=40]{Programs/counter.nt}
	
	\item implementing each method of the type using a lambda that takes a sealed parameter \iil/ob.self/ representing the receiver (and which the \iil/self/ value maps to) plus any parameters defined on the method; and finally,
	\item sealing the capability of each of the type's methods.
	\ilfile[firstline=41, lastline=76]{Programs/counter.nt}
	
\end{enumerate}

Each method invocation is \lowered{} by evaluating the \g{methcap} with the receiver as the first argument, followed by any provided arguments. Object construction in \texttt{object} values is implemented in NT by calling the metatype's \texttt{createObject} \g{methcap} on the type object.
\ilfile[firstline=77]{Programs/counter.nt}

\section{Changes to Glyco} \label{sct:obj-changes}
% TODO

\section{Evaluation} \label{sct:obj-eval}
% TODO

% \biblio{} TODO: Uncomment after adding a citation in chapter.
\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
