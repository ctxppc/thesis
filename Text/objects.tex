\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}}

\chapter{Sealed Objects}
The previous chapter discussed a first extension of the Glyco compiler, namely a secure calling convention. This chapter treats a second extension, a feature we call \emph{sealed objects}.

Sealed objects depend on two new features; we begin hence by describing lambdas in \cref{sct:lambda} and named \& nominal types in \cref{sct:named-ty} before defining the semantics of objects and methods in \cref{sct:obj-meth}. We then list in \cref{sct:obj-sec} a few security properties afforded by sealed objects. We finish this chapter by outlining the changes to the compiler in \cref{sct:obj-changes} and evaluating sealed objects in \cref{sct:obj-eval}.

This chapter discusses the feature set and languages of Glyco 1.0.\footnote{The source code is available at \url{https://tsarouhas.eu/glyco/1.0/}.} A full language reference can be found in \cref{ch:grammar}.

\section{Lambdas} \label{sct:lambda}
A first addition to Glyco is the \textbf{lambda}, i.e., an anonymous function, in a new \g{il} called \textbf{Λ} (Lambdas) above EX. Lambdas allow the programmer to define functions (\texttt{λ} values) at the point of use and to pass them around as values. For example, the following Λ program defines a lambda that computes the sum of its two parameters and immediately applies it on $1080$ and $-80$.
\ilfile{Programs/sum.l}

The scope of a lambda definition extends beyond the \texttt{λ} value itself to the \texttt{let} value defining it, in a similar way to \texttt{letRec} values in some functional programming languages and unlike definitions of other kinds of values. This enables mutual recursion such as the following (inefficient) program determining the parity of 420.
\ilfile{Programs/evenodd.l}

Finally, since \texttt{λ} values with support for mutual recursion provide the same expressive power as programs with global functions, Λ removes support for global functions. The reader should bear in mind however that lambdas do not \emph{increase} the expressive power of programs but merely make it easier to define functions. Lambda values evaluate to code capabilities and do not carry an environment; lambdas in Λ aren't closures.

\paragraph{From Λ to EX} The \g{nanopass} from Λ to EX extracts the functions defined by \texttt{λ} values into the global scope (with either an auto-generated name or a name derived from the lambda definition) and replaces the \texttt{λ} values by code capabilities to those functions. The first program of this chapter is thus \lowered{} to the EX program
\ilfile{Programs/sum.ex}

\section{Alias \& Nominal Types} \label{sct:named-ty}
A second new feature is support for defining new (named) types in a new \g{il} \textbf{NT} (Named Types) above Λ. A value in NT can be
\begin{itemize}[nosep]
	\item an (8-bit) byte, a \iil/u8/;
	\item a (32-bit) signed integer, an \iil/s32/;
	\item a capability to a vector of \iil/T/s, a \iil/cap(vector(T, sealed: S))/;
	\item a capability to a record, a \iil/cap(record((name, Type) …, sealed: S))/;
	\item a capability to a function, a \iil/cap(function(takes: p …, returns: r))/;
	\item a \g{sealcap}, a \iil/cap(seal(sealed: S))/; or
	\item a value of a type named \iil/T/
\end{itemize}
where \iil/S/ is \iil/true/ if the capability is sealed and \iil/false/ otherwise. A type can be defined using a \textbf{\texttt{letType} value} in one of two ways.

\paragraph{Alias types} An \textbf{alias type definition} creates an \textbf{alias type}, a type that is equivalent to the type it's defined as. An alias type can have a shorter or semantically meaningful type name that the type it's defined as.

For instance, the following NT program defines an alias type named \iil/Sequence/ and uses it in a simple computation that evaluates to 4. The value \iil/pi/ created by \iil/vector(s32, count: 3)/ is typed \iil/cap(vector(s32, sealed: false))/ but is accepted by the function which takes an argument typed \iil/Sequence/.
\ilfile{Programs/alias.nt}

\paragraph{Nominal types} A \textbf{nominal type definition} creates a \textbf{nominal type}, a type which is only equivalent to itself. A nominal type is effectively a new type by itself and can be used to ensure that two representationally identical but semantically different types of values cannot accidentally be mixed. However, a value can be explicitly \texttt{cast}ed to a value of a different type that has the same representation.

For example, the following NT program defines two nominal types \iil/Kelvin/ and \iil/Celsius/ and uses them to convert 500 °C to K and back to °C.
\ilfile{Programs/temp.nt}

However, the following program is not valid since the second invocation of \iil/toCelsius/, which excepts a value in \iil/Kelvin/, is given a value in \iil/Celsius/. Nominal type rules prevent the accidental conversion from \iil/Kelvin/ to \iil/Celsius/, even though both types are represented by \iil/s32/.
\ilfile{Programs/tempbad.nt}

\begin{quote}
	\ttfamily\footnotesize
	Error: \iil/evaluate(toCelsius, 500)/ is of type \iil/named(Celsius)/ and thus cannot be used for \iil/(k, Kelvin, sealed: false)/
\end{quote}

\paragraph{Implicit type casts} With some exceptions, the type checker rejects any uses of values of a structural type such as \iil/s32/ in contexts where a nominal type is expected and vice versa. This restriction can be bypassed using a \texttt{cast}. For ergonomic reasons, the type-checker performs an implicit cast on
\begin{itemize}[nosep]
	\item an argument of structural type that is passed to a parameter of nominal type, like in \iil/evaluate(toKelvin, 500)/ above;
	\item a record value of nominal type in a \texttt{field} value;
	\item a vector value of nominal type in an \texttt{element} value;
	\item a seal value of nominal type in a \texttt{sealed} value;
	\item an operand of structural type in a \texttt{binary} value when the other operand is of nominal type — the result of the \texttt{binary} value is of nominal type;
	\item a lambda's result value of structural type when the result type is nominal; and
	\item a program's result value of nominal type (to \iil/s32/), like the result in \iil/Celsius/ above.
\end{itemize}

\paragraph{From NT to Λ} The \g{nanopass} from NT to Λ replaces named types by their Λ equivalents and checks if the nominal typing rules hold.

\section{Objects \& Methods} \label{sct:obj-meth}
A \textbf{sealed object} (or simply \textbf{object} in this chapter) is an encapsulated record on which a predefined set of functions can operate. These functions are the object's \textbf{\gs{method}}.

An object belongs to an \textbf{object type}, which determines the record type and \gs{method} of all objects of that type. Sealed objects in Glyco are in this respect similar to objects in object-oriented programming languages such as Java. Object types however do not support inheritance and record fields cannot be made visible outside of \gs{method}.

Object types can be defined using an \textbf{object type definition} in a \texttt{letType} value. A definition consists of
\begin{itemize}[nosep]
	\item a name, like any other type definition;
	\item a record type specifying the structure of each object's state;
	\item an initialiser effect applied on all new objects accepting zero or more parameters; and
	\item zero or more \gs{method}.
\end{itemize}

An \textbf{\g{init}} is a pseudo-\g{method} automatically invoked on every new object immediately after its state is allocated that ensures that the object has the right initial state. An object can be created using an \texttt{object} value, which accepts a type name and arguments to the initialiser's parameters. \Gs{method} can only be defined when the object type is being defined. They can be invoked using a \texttt{message} value, which takes an object, \g{method} name, and arguments to the \g{method}'s parameters. Initialisers and \gs{method} alike get a capability to the object's state, i.e., the record composing it, through the \iil/self/ value.

The following OB program implements the object type \iil/Counter/, creates a counter with an initial value of 32, increases the count three times, and evaluates to the counter's final value (35):
\ilfile{Programs/counter.ob}

\section{Object State Encapsulation \& Unique Seals} \label{sct:obj-sec}
The first important security property afforded by sealed objects is that an object's state is \textbf{only accessible within the \g{init} or a \g{method} defined during object type definition} in \texttt{letType}.\footnote{This property does not hold if the initialiser or a method leaks a capability to the state record. Our threat model assumes trust in an object type's implementation.} A second security property is that an \g{init} or method \textbf{can only be invoked on an object of the type defining that \g{init} or \g{method}}.\footnote{This property similarly does not hold if a capability to the \g{init}'s or \g{method}'s code is leaked.}

Both properties are achieved by \g{sealing} capabilities to objects, \gs{method}, and \gs{init} using unique \gs{sealcap} provided by a \g{rtrt}. \G{sealing} capabilities using a \g{sealcap} is a power which was originally bestowed upon the \g{rt} in the design and implementation of \g{ghscc} where an \g{scall} seals a return–frame capability pair before passing control to the callee.

An \textbf{\g{objcap}} is a sealed capability to a record embodying an object. A \textbf{\g{methcap}} is a sealed code capability to a \g{method} or \g{init}. Due to their sealed nature, \gs{objcap} cannot be used in an \texttt{getField} value or \texttt{setField} effect and similarly \gs{init} and \gs{methcap} cannot be used in an \texttt{evaluate} value.\footnote{A \texttt{getField} value is eventually \lowered{} to a load instruction in the CHERI-RISC-V language. A \texttt{setField} effect is eventually \lowered{} to a store instruction. An \texttt{evaluate} value is eventually \lowered{} to a \texttt{CJALR} jump instruction and some other instructions surrounding it. Loading or storing using a sealed capability or jumping to a sealed code capability using \texttt{CJALR} results in a machine trap.}

Object and method capabilities are sealed using the same \g{sealcap}; a \g{methcap} can therefore be invoked on an \g{objcap} using the \texttt{CInvoke} CHERI-RISC-V instruction. This immediately poses an issue in protecting the \g{sealcap} while at the same still allowing arbitrary clients to create new objects and thus derive new \gs{objcap}.

\subsection{Object Types Are Objects}
% TODO

\section{Changes to Glyco} \label{sct:obj-changes}
% TODO

\section{Evaluation} \label{sct:obj-eval}
% TODO

% \biblio{} TODO: Uncomment after adding a citation in chapter.
\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
