\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}}

\chapter{Conclusion}
The primary goal of this thesis is to explore a design and implementation of a compiler using a \g{nanopass} approach for experimenting with security features built on CHERI-RISC-V capabilities. A second goal is to evaluate the approach itself in terms of how well it lends itself to experimentation with (radically) new ideas. This second goal motivates the structure of the thesis text: \crefrange{ch:glyco}{ch:cls} each present a milestone of the compiler.

The text begins in \cref{ch:cheri} with a brief introduction to capability machines and the CHERI-RISC-V architecture.

\Cref{ch:glyco} then explores the basic version of a \g{nanopass} compiler, which we named \emph{Glyco}. The design of this first version of the compiler is adapted from an existing x86 student compiler by \citet{compcourse}. The basic version of the compiler provides almost no features specifically enabled by capability support in hardware and is intended as a baseline for extensions. The compiler implements procedure calls using a \g{cc} named \g{gccc} that looks like most traditional \gs{cc} used in the field.

The first upgrade of Glyco is the addition of a secure \g{cc} named \emph{\g{ghscc}}, a variant of a \g{cc} proposed by \citet{cerise}, which is discussed in \cref{ch:ghscc}. Unlike \g{gccc}, \g{ghscc} organises call frames in a linked list in heap-allocated memory. As part of this extension, we also improve the heap allocator by implementing it as a \g{rtrt} and encapsulating the \g{heapcap} in it, ensuring that user programs cannot derive capabilities to arbitrary regions of the heap while still allowing them to get access to heap memory allocated by them. \G{ghscc} provides \g{lse} as described by \citet[Section~1]{stktokens}, a security property guaranteeing that the local state of a procedure call cannot be accessed from other procedures/calls. Additionally, \g{ghscc} provides a security property we call \emph{unrepeatable return} which guarantees that a \g{retcap} can be used at most once, a weaker variant of the \g{wbcf} security property also described by \citet[Section~1]{stktokens}. These properties continue to hold even if a Glyco-built program were to interoperate with untrusted code written in assembly.

The second addition to Glyco is a feature we call \emph{sealed objects}, which are similar to objects in object-oriented languages but whose state is inaccessible outside methods defined during type definition. This form of encapsulation is enforced using sealed capabilities, meaning that such code could securely interoperate with code written in assembly.

The third and final addition to Glyco is an application of sealed objects, \emph{sealed closures}, which are closures whose captured environment cannot be accessed outside of the closure body, even if the closure is passed to untrusted code.

\section{Nanopass Approach}
The \g{nanopass} approach allows a compiler designer to manage complexity by representing programs in several abstractions and performing actions at a suitable abstraction. For instance, the \g{cc} is imposed at an abstraction where structured values, abstract locations, and registers are available. Structured values are introduced in SV and are used for creating arguments records when not all arguments fit in registers. Abstract locations are introduced in ALA and are used for binding the contents of \g{ceesaved} to names. Not all \gs{ceesaved} need to be saved so the register allocator in a later \g{nanopass} cleans up (some) redundant moves. It does so purely using liveness information; it has no knowledge about the \g{cc}. As a compiler designer, we also want to limit complexity by removing low-level features such as direct register access in as many languages as we can. CC, i.e., the language introducing the \g{cc}, is therefore introduced right above ALA and SV. It is also the lowest language without syntax for accessing registers. A single intermediate language such as LLVM IR brings all abstractions together and compiler passes are loosely sequenced, as opposed to the rigidly ordered \gs{nanopass} in Glyco and the student compiler mentioned above.

Working with tens of \gs{il} is nevertheless also a challenge, especially since it can cause significant code duplication. An \g{il} usually differs little from its \g{lowerlang}, so \g{nanopass} compilers commonly use a framework (such as one described by \citet{educomp} for educational compilers). We chose to write the compiler in Swift, a strongly typed programming language with data-flow analysis, exhaustive pattern match checking, result builders, and custom operators. The first two features as well as strong typing ensure that each syntactical element in an \g{il} is properly handled while result builders and custom operators make it possible to define a domain-specific language within Swift, which in turn allows us to write \gs{nanopass} in a more natural way. However, we did not find a \g{nanopass} framework written in Swift, which means that our codebase contains a lot of duplication. While we do use code generation tools such as Sourcery,\footnote{Sourcery is available at \url{https://github.com/krzysztofzablocki/Sourcery}.} \gs{nanopass} still need to be written exhaustively. The Swift compiler's aforementioned static analysis features reduce the development time but this isn't reflected in the SLOC metric of our evaluation. A \g{nanopass} framework allows one to omit unchanged syntactical elements and trivial \gs{nanopass} and would make SLOC metrics more meaningful.

\section{Future Directions}
\paragraph{More \gs{cc}} Glyco currently provides two \gs{cc}, one of which is \enquote{secure.} An obvious future direction is to add more secure \gs{cc}, especially ones proposed in the literature which provide full \g{wbcf}.

\paragraph{Continuations} Heap-allocated call frames (\g{ghscc}), \gs{retcap}, and closures can be naturally generalised to first-class support for continuations.

One possible approach is to introduce continuations at a relatively low level in CC (and \gs{il} near it) by introducing continuation values, which are similar to procedure values, except that they do not return. Just like procedures, continuations accept arguments and can be invoked using \texttt{call} effects. Every procedure has an implicit return continuation; the \texttt{return} effect is repurposed to invoke this implicit return continuation. The \texttt{call} effect is also extended with support to perform a call-with-current-continuation (known as \texttt{call/cc} in Scheme): any omitted arguments to a parameter of continuation type are filled in with a continuation following the call.

Another approach is to build continuations at the very top of the current compiler pipeline by relying on existing object and closure infrastructure, in a new \g{il} CO (and probably a few more \gs{il} under it). CO introduces \texttt{evaluateWithCurrentContinuation} values; one or more \gs{nanopass} extract continuations from these values as lambdas. Continuations can be executed using a \texttt{continue} tail effect. Continuations can accept arguments and do not return.

\paragraph{More generic programming} The current implementation of Glyco uses some generic programming to reduce code duplication (such as the \texttt{Name}, \texttt{Codable}, \texttt{Language}, and \texttt{ComposableEffect} protocols) but a future direction could be to use it much more extensively.

One concrete example would be to define a range of protocols specialising \texttt{Language}, with each subprotocol declaring some common syntactical elements provided by two or more \gs{il}. All \gs{il} above CC could for instance conform to a \texttt{ValueLanguage} protocol which would declare a \texttt{Value} associated type. Syntactical element types would accept a type parameter constrained to one or more language protocols. \texttt{Result} could for instance accept a type conforming to \texttt{ValueLanguage}. \texttt{ValueLanguage} could then provide a \texttt{Result} type-alias that is defined as \texttt{Result<Self>}. There would no longer be a need to duplicate \texttt{Result} since occurrences of \texttt{Value} would automatically be bound to the right concrete \texttt{Value} type for that language. The same would be done for the majority of syntactical elements appearing in more than one \g{il}.

\paragraph{\Gs{bblock}} The student compiler by \citet{compcourse} has a few \gs{il} relating to \gs{bblock} which Glyco adapts. However, neither compiler defines optimisations such as common subexpression elimination that are commonly done on \gs{bblock}. As a possible improvement, we could either implement a few of such optimisations, or simplify the codebase by omitting the \g{bblock} \gs{il} (BB and PR) altogether.

% TODO: Closing remarks?

\biblio{}
\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
