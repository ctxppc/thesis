\newglossaryentry{sealing}{
	name=sealing,
	description={the act of setting the object type of an unsealed capability to either the address of a \g{sealcap} or to a special value indicating that it is a \g{sentry}, so that it can no longer be modified or dereferenced until it is \glslink{unsealing}{unsealed} again}
}

\newglossaryentry{unsealing}{
	name=unsealing,
	description={the act of setting the object type of a sealed capability to $-1$ so that it is no longer sealed and thus can be used normally}
}

\newglossaryentry{sentry}{
	name=sentry capability,
	plural=sentry capabilities,
	description={a sealed entry capability, a sealed capability created with the \iasm/CSealEntry/ instruction which can only be unsealed by jumping to its address using the \iasm/CJALR/ instruction}
}

\newglossaryentry{sealcap}{
	name=seal capability,
	plural=seal capabilities,
	description={a capability with the \emph{Permit seal} permission which can be used with the \iasm/CSeal/ instruction to seal an unsealed capability with the seal capability's address}
}

\newglossaryentry{unsealcap}{
	name=unseal capability,
	plural=unseal capabilities,
	description={a capability with the \emph{Permit unseal} permission which can be used with the \iasm/CUnseal/ instruction to unseal a capability sealed with the unseal capability's address}
}

\newglossaryentry{otype}{
	name=object type,
	description={a numerical property of a capability indicating if it is unsealed (object type $-1$), sealed as a \g{sentry} (object type $-2$), or sealed using a \g{sealcap} (object type matching the \g{sealcap}'s address)}
}

\newdualentry{il}{IL}{intermediate language}{a language produced or parsed by a \gls{nanopass} as part of the compiler's routine}

\newglossaryentry{lowering}{
	name=lowering,
	description={the act of transforming a higher-level to a lower-level intermediate language through one or more nanopasses}
}
\newcommand{\lowered}{\glslink{lowering}{lowered}}

\newglossaryentry{nanopass}{
	name=nanopass,
	plural=nanopasses,
	description={a function that transforms a program in one \gls{il} to a program in another \gls{il}}
}

\newglossaryentry{lowerlang}{
	name=lower language,
	description=the \g{il} output by a single \g{lowering} of a program in the \g{il} currently being discussed
}

\newglossaryentry{cc}{
	name=calling convention,
	description={a set of rules governing the invocation of procedures on a specific platform and architecture dealing with matters such as argument \& result passing, register availability, call frame structure, jumping to the callee, and returning to the caller}
}

\newdualentry{gccc}{GCCC}{Glyco Conventional Calling Convention}{a \g{cc} implemented in Glyco that is similar to a RISC-V \g{cc}}

\newdualentry{ghscc}{GHSCC}{Glyco Heap-based Secure Calling Convention}{a \g{cc} implemented in Glyco that ensures \gls{lse} by securely allocating call frames on the heap, clearing non-argument and non-result registers before passing control, and sealing return \& frame capabilities with a unique seal before invocation}

\newglossaryentry{lse}{
	name=local state encapsulation,
	description={a security property guaranteeing that a procedure's state cannot be accessed by adversarial code in the same address space}
}

\newglossaryentry{wbcf}{
	name=well-bracketed control flow,
	description={a security property guaranteeing that a procedure can only invoke other procedures, return to its caller, or diverge}
}

\newglossaryentry{retcap}{
	name=return capability,
	plural=return capabilities,
	description={a capability containing a return address allowing a procedure to return to its caller}
}

\newglossaryentry{userp}{
	name=user program,
	description={a program not provided by the compiler or operating system, normally contrasted with the \g{rt}}
}

\newglossaryentry{rt}{
	name=runtime,
	description={compiler-provided software that runs at program startup, initialises data structures that are needed as part of the operation of the user program, and provides routines with privileges normally not afforded to \gs{userp}}
}

\newglossaryentry{rtrt}{
	name=runtime routine,
	description={a procedure provided by the runtime with a possibly different \g{cc} and more privileges afforded to it than a normal procedure}
}

\newglossaryentry{cersaved}{
	name=caller-saved register,
	description={a register that a procedure can use freely but whose contents it must save if it wishes to preserve them across a procedure call; contrast with \g{cersaved}}
}

\newglossaryentry{ceesaved}{
	name=callee-saved register,
	description={a register that a procedure can only use after saving its previous contents, to be restored when the procedure is done using the register; contrast with \g{cersaved}}
}

\newglossaryentry{stackcap}{
	name=stack capability,
	plural=stack capabilities,
	description={a capability in the \texttt{csp} register that points to the last pushed datum on the call stack, i.e., the top of the stack}
}

\newglossaryentry{framecap}{
	name=frame capability,
	plural=frame capabilities,
	description={a capability in the \texttt{cfp} register that points to the base of the current call frame}
}

\newglossaryentry{heapcap}{
	name=heap capability,
	plural=heap capabilities,
	description={a capability that grants access to the heap and points to the next free location}
}

\newglossaryentry{bblock}{
	name=basic block,
	description={a labelled sequence of effects that is executed from beginning to end, before jumping or branching to itself or to other blocks. No effect in the block but the first is labelled. No effect except the continuation is a jump, call, or branch}
}

\newglossaryentry{scall}{
	name=s-call,
	description={a procedure call mediated by the s-call \g{rtrt} which seals the frame and return capabilities using a unique \g{sealcap}, thereby ensuring the callee cannot dereference either capability and requiring that the callee use \iasm/CInvoke/ to return to the caller}
}

\newglossaryentry{init}{
	name=initialiser,
	description={a pseudo-\g{method} invoked on any new object of the type for which the initialiser is defined, ensuring that the new object has an appropriate initial state}
}

\newglossaryentry{method}{
	name=method,
	description={a function that can be invoked on an object and gets access to the object's state, if defined on the same type as the object}
}

\newglossaryentry{objcap}{
	name=object capability,
	plural=object capabilities,
	description={a capability to a state record embodying a sealed object, sealed with a \g{sealcap} only used for objects and methods of the same object type}
}

\newglossaryentry{methcap}{
	name=method capability,
	plural=method capabilities,
	description={a capability to a method's code, sealed with a \g{sealcap} only used for objects and methods of the same object type}
}

\makeglossaries