\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}}

\chapter{Sealed Closures} \label{ch:cls}
The preceding chapter introduced sealed objects, objects whose state can only be accessed via dedicated methods. This chapter presents an application of sealed objects, a new feature we call \emph{sealed closures}.

\Cref{sct:cls-trad} sets out how closures are usually implemented and what problems these methods suffer from. \Cref{sct:cls-sealed} then presents a sealed object-based solution and a new \g{il}. Finally, we evaluate the nanopass approach's impact on the codebase in \cref{sct:cls-eval}.

\section{Traditional Closures} \label{sct:cls-trad}
A \textbf{closure} is a function that can use the environment\footnote{An environment, and more specifically a \emph{value environment}, can be seen as a mapping from names to values, with each definition adding or updating entries in it and the environment being consulted whenever a name is mentioned in the program. That is of course not what really happens in an ahead-of-time compiler such as Glyco where the environment consists of registers and memory locations, and the mapping mostly implemented by the register allocator.} wherein the closure is defined during its operation, i.e., names (variables) valid at the point of the closure definition can also be used in the closure body. The closure is said to \textbf{capture} or \textbf{save} the environment or to \textbf{capture} variables from the \textbf{outer scope}.

The following Swift program uses a closure to print all numbers between 1 and 100, increased by \texttt{offset}.
\begin{minted}[style=xcode]{Swift}
	let offset = 5
	let numbers = (1...100)
		.map { number in number + offset }
	print(numbers)		// 6, 7, 8, 9, 10, …
\end{minted}
The closure takes one parameter \texttt{number} and captures the constant \texttt{offset} from the outer scope. The \texttt{map} method invokes the closure for every number between 1 and 100 inclusive, binding each number to the \texttt{number} parameter. The closure also gets access to \texttt{offset} even though \texttt{map} isn't even aware of it.

Closures are usually implemented by pairing a function with an environment. When the pair is invoked, the function is invoked with the environment as a (hidden) parameter. For instance, the following OB program implements a closure \texttt{closure} that takes a single parameter \texttt{n} and captures an environment with a single captured name \texttt{offset}.
\ilfile{Programs/fakecls.ob}

The closure here is implemented as a capability to a record containing a code capability \texttt{function} and a capability \texttt{env} to a record containing fields for each captured value (here just \texttt{offset}). This closure capability (to the function–environment record) can be passed around the program and eventually invoked as shown above — \iil/600/ is in this example the argument to the closure.

The contents of a closure's saved environment are established at the point of closure definition. In most programmer models, the captured value \iil/offset/ from the example above should remain fixed at \iil/5/, which is the value of \iil/offset/ at closure definition. A user of a closure should not be able to execute the closure with a different value for \iil/offset/ than the closure's creator intended. They should only be able to influence the closure's result by providing different arguments, and possibly by influencing any global state that the user has access to and the closure relies on.

In this OB example, it's almost trivially simple to change the value of the \iil/offset/ field, e.g., \iil/do(setField(offset, of: env, to: 10), then: evaluate(…))/.

\section{Sealed Closures} \label{sct:cls-sealed}
The encapsulation problem presented in the previous section is solved in \textbf{sealed closures}, which are closures whose \textbf{captured environment cannot be changed}, except from within the closure. Sealed closures are presented in a new \g{il} \textbf{CL} (Closures) which is built on top of OB. CL does not provide any new syntax but instead increases the expressive power provided by λ values, which can now mention names defined outside of the lambda definition.

The OB closure example above can now be expressed more elegantly as
\ilfile[samepage=true]{Programs/offset.cl}

% TODO

The above OB program is \lowered{} to
\ilfile{Programs/offset.ob}

\section{Evaluation} \label{sct:cls-eval}
% TODO

\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
