
\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}\appendix{}}

\chapter{Language Reference}
\label{ch:grammar}
This chapter presents all \gs{il} in the final version of Glyco, from high-level to low-level languages. The Swift source files for these \gs{il} can be found under \url{https://tsarouhas.eu/glyco/ils}.

\paragraph{ OB (Objects) } A language that introduces objects, i.e., encapsulated values with methods.
\begin{grammar}
	\footnotesize
				<OB.Program> ::=
							"("<Result>, "functions:" <[Function]>")"
				\par
				<OB.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Value>, <BranchRelation>, <Value>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "let""("<[Definition]>, "in:" <Predicate>")"
				\par
				<OB.Parameter> ::=
							"("<Symbol>, <ValueType>")"
				\par
				<OB.Initialiser> ::=
							"(""takes:" <[Parameter]>, "in:" <Effect>")"
				\par
				<OB.Function> ::=
							"("<Label>, "takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Result>")"
				\par
				<OB.RecordType> ::=
							"("<[Field]>")"
				\par
				<OB.Field> ::=
							"("<Name>, <ValueType>")"
				\par
				<OB.Effect> ::=
						"do""("<[Effect]>")"
						| "let""("<[Definition]>, "in:" <Effect>")"
						| "setField""("<Field.Name>, "of:" <Value>, "to:" <Value>")"
						| "setElement""(""of:" <Value>, "at:" <Value>, "to:" <Value>")"
				\par
				<OB.Value> ::=
						"self"
						| "constant""("<Int>")"
						| "named""("<Symbol>")"
						| "record""("<RecordType>")"
						| "field""("<Field.Name>, "of:" <Value>")"
						| "vector""("<ValueType>, "count:" <Int>")"
						| "element""(""of:" <Value>, "at:" <Value>")"
						| "λ""(""takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Result>")"
						| "object""("<TypeName>, <[Value]>")"
						| "function""("<Label>")"
						| "binary""("<Value>, <BinaryOperator>, <Value>")"
						| "evaluate""("<Value>, <[Value]>")"
						| "message""("<Value>, <Method.Name>, <[Value]>")"
						| "if""("<Predicate>, "then:" <Value>, "else:" <Value>")"
						| "let""("<[Definition]>, "in:" <Value>")"
						| "letType""("<[TypeDefinition]>, "in:" <Value>")"
						| "do""("<[Effect]>, "then:" <Value>")"
				\par
				<OB.ObjectType> ::=
							"(""name:" <TypeName>, "initialiser:" <Initialiser>, "methods:" <[Method]>, "state:" <RecordType>")"
				\par
				<OB.Result> ::=
						"value""("<Value>")"
						| "evaluate""("<Value>, <[Value]>")"
						| "if""("<Predicate>, "then:" <Result>, "else:" <Result>")"
						| "let""("<[Definition]>, "in:" <Result>")"
						| "do""("<[Effect]>, "then:" <Result>")"
				\par
				<OB.ValueType> ::=
						"named""("<TypeName>")"
						| "u8"
						| "s32"
						| "cap""("<CapabilityType>")"
				\par
				<OB.CapabilityType> ::=
						"vector""(""of:" <ValueType>")"
						| "record""("<RecordType>")"
						| "function""(""takes:" <[Parameter]>, "returns:" <ValueType>")"
						| "object""("<TypeName>")"
						| "seal"
				\par
				<OB.Method> ::=
							"("<Symbol>, "takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Result>")"
				\par
				<OB.Definition> ::=
							"("<Symbol>, <Value>")"
				\par
				<OB.TypeDefinition> ::=
						"structural""("<TypeName>, <ValueType>")"
						| "nominal""("<TypeName>, <ValueType>")"
						| "object""("<ObjectType>")"
				\par
\end{grammar}
\par
\paragraph{ NT (Named Types) } A language that introduces named structural and nominal types.
\begin{grammar}
	\footnotesize
				<NT.Program> ::=
							"("<Result>, "functions:" <[Function]>")"
				\par
				<NT.Effect> ::=
						"do""("<[Effect]>")"
						| "let""("<[Definition]>, "in:" <Effect>")"
						| "setField""("<Field.Name>, "of:" <Value>, "to:" <Value>")"
						| "setElement""(""of:" <Value>, "at:" <Value>, "to:" <Value>")"
				\par
				<NT.GlobalDeclaration> ::=
				\par
				<NT.CapabilityType> ::=
						"vector""(""of:" <ValueType>, "sealed:" <Bool>")"
						| "record""("<RecordType>, "sealed:" <Bool>")"
						| "function""(""takes:" <[Parameter]>, "returns:" <ValueType>")"
						| "seal""(""sealed:" <Bool>")"
				\par
				<NT.Result> ::=
						"value""("<Value>")"
						| "evaluate""("<Value>, <[Value]>")"
						| "if""("<Predicate>, "then:" <Result>, "else:" <Result>")"
						| "let""("<[Definition]>, "in:" <Result>")"
						| "do""("<[Effect]>, "then:" <Result>")"
				\par
				<NT.TypeDefinition> ::=
						"structural""("<TypeName>, <ValueType>")"
						| "nominal""("<TypeName>, <ValueType>")"
				\par
				<NT.Value> ::=
						"constant""("<Int>")"
						| "named""("<Symbol>")"
						| "record""("<RecordType>")"
						| "field""("<Field.Name>, "of:" <Value>")"
						| "vector""("<ValueType>, "count:" <Int>")"
						| "element""(""of:" <Value>, "at:" <Value>")"
						| "λ""(""takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Result>")"
						| "function""("<Label>")"
						| "seal"
						| "sealed""("<Value>, "with:" <Value>")"
						| "binary""("<Value>, <BinaryOperator>, <Value>")"
						| "evaluate""("<Value>, <[Value]>")"
						| "if""("<Predicate>, "then:" <Value>, "else:" <Value>")"
						| "let""("<[Definition]>, "in:" <Value>")"
						| "letType""("<[TypeDefinition]>, "in:" <Value>")"
						| "do""("<[Effect]>, "then:" <Value>")"
				\par
				<NT.Definition> ::=
							"("<Symbol>, <Value>")"
				\par
				<NT.RecordType> ::=
							"("<[Field]>")"
				\par
				<NT.Field> ::=
							"("<Name>, <ValueType>")"
				\par
				<NT.TypeName> ::=
						<String>
				\par
				<NT.Function> ::=
							"("<Label>, "takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Result>")"
				\par
				<NT.ValueType> ::=
						"named""("<TypeName>")"
						| "u8"
						| "s32"
						| "cap""("<CapabilityType>")"
				\par
				<NT.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Value>, <BranchRelation>, <Value>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "let""("<[Definition]>, "in:" <Predicate>")"
				\par
				<NT.Parameter> ::=
							"("<Symbol>, <ValueType>, "sealed:" <Bool>")"
				\par
\end{grammar}
\par
\paragraph{ Λ (Lambdas) } A language that introduces anonymous functions and function values.
\begin{grammar}
	\footnotesize
				<Λ.Program> ::=
							"("<Result>, "functions:" <[Function]>")"
				\par
				<Λ.Value> ::=
						"constant""("<Int>")"
						| "named""("<Symbol>")"
						| "record""("<RecordType>")"
						| "field""("<Field.Name>, "of:" <Value>")"
						| "vector""("<ValueType>, "count:" <Int>")"
						| "element""(""of:" <Value>, "at:" <Value>")"
						| "λ""(""takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Result>")"
						| "function""("<Label>")"
						| "seal"
						| "sealed""("<Value>, "with:" <Value>")"
						| "binary""("<Value>, <BinaryOperator>, <Value>")"
						| "evaluate""("<Value>, <[Value]>")"
						| "if""("<Predicate>, "then:" <Value>, "else:" <Value>")"
						| "let""("<[Definition]>, "in:" <Value>")"
						| "do""("<[Effect]>, "then:" <Value>")"
				\par
				<Λ.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Value>, <BranchRelation>, <Value>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "let""("<[Definition]>, "in:" <Predicate>")"
				\par
				<Λ.Effect> ::=
						"do""("<[Effect]>")"
						| "let""("<[Definition]>, "in:" <Effect>")"
						| "setField""("<Field.Name>, "of:" <Value>, "to:" <Value>")"
						| "setElement""(""of:" <Value>, "at:" <Value>, "to:" <Value>")"
				\par
				<Λ.Function> ::=
							"("<Label>, "takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Result>")"
				\par
				<Λ.Result> ::=
						"value""("<Value>")"
						| "evaluate""("<Value>, <[Value]>")"
						| "if""("<Predicate>, "then:" <Result>, "else:" <Result>")"
						| "let""("<[Definition]>, "in:" <Result>")"
						| "do""("<[Effect]>, "then:" <Result>")"
				\par
				<Λ.Definition> ::=
							"("<Symbol>, <Value>")"
				\par
\end{grammar}
\par
\paragraph{ EX (Expressions) } A language that introduces expression semantics for values, thereby abstracting over computation effects.
\begin{grammar}
	\footnotesize
				<EX.Program> ::=
							"("<Result>, "functions:" <[Function]>")"
				\par
				<EX.Value> ::=
						"constant""("<Int>")"
						| "named""("<Symbol>")"
						| "record""("<RecordType>")"
						| "field""("<Field.Name>, "of:" <Value>")"
						| "vector""("<ValueType>, "count:" <Int>")"
						| "element""(""of:" <Value>, "at:" <Value>")"
						| "function""("<Label>")"
						| "seal"
						| "sealed""("<Value>, "with:" <Value>")"
						| "binary""("<Value>, <BinaryOperator>, <Value>")"
						| "evaluate""("<Value>, <[Value]>")"
						| "if""("<Predicate>, "then:" <Value>, "else:" <Value>")"
						| "let""("<[Definition]>, "in:" <Value>")"
						| "do""("<[Effect]>, "then:" <Value>")"
				\par
				<EX.Definition> ::=
							"("<Symbol>, <Value>")"
				\par
				<EX.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Value>, <BranchRelation>, <Value>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "let""("<[Definition]>, "in:" <Predicate>")"
				\par
				<EX.Function> ::=
							"("<Label>, "takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Result>")"
				\par
				<EX.Effect> ::=
						"do""("<[Effect]>")"
						| "let""("<[Definition]>, "in:" <Effect>")"
						| "setField""("<Field.Name>, "of:" <Value>, "to:" <Value>")"
						| "setElement""(""of:" <Value>, "at:" <Value>, "to:" <Value>")"
				\par
				<EX.Result> ::=
						"value""("<Value>")"
						| "evaluate""("<Value>, <[Value]>")"
						| "if""("<Predicate>, "then:" <Result>, "else:" <Result>")"
						| "let""("<[Definition]>, "in:" <Result>")"
						| "do""("<[Effect]>, "then:" <Result>")"
				\par
\end{grammar}
\par
\paragraph{ LS (Lexical Scopes) } A language that introduces lexical scopes of definitions, thereby removing name clashes.
\begin{grammar}
	\footnotesize
				<LS.Program> ::=
							"("<Result>, "functions:" <[Function]>")"
				\par
				<LS.Symbol> ::=
						<String>
				\par
				<LS.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Source>, <BranchRelation>, <Source>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "let""("<[Definition]>, "in:" <Predicate>")"
				\par
				<LS.Parameter> ::=
							"("<Symbol>, <ValueType>, "sealed:" <Bool>")"
				\par
				<LS.ValueType> ::=
						"u8"
						| "s32"
						| "cap""("<CapabilityType>")"
				\par
				<LS.Value> ::=
						"source""("<Source>")"
						| "binary""("<Source>, <BinaryOperator>, <Source>")"
						| "record""("<RecordType>")"
						| "field""("<Field.Name>, "of:" <Symbol>")"
						| "vector""("<ValueType>, "count:" <Int>")"
						| "element""(""of:" <Symbol>, "at:" <Source>")"
						| "seal"
						| "sealed""("<Symbol>, "with:" <Symbol>")"
						| "evaluate""("<Source>, <[Source]>")"
						| "if""("<Predicate>, "then:" <Value>, "else:" <Value>")"
						| "let""("<[Definition]>, "in:" <Value>")"
						| "do""("<[Effect]>, "then:" <Value>")"
				\par
				<LS.Function> ::=
							"("<Label>, "takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Result>")"
				\par
				<LS.CapabilityType> ::=
						"vector""(""of:" <ValueType>, "sealed:" <Bool>")"
						| "record""("<RecordType>, "sealed:" <Bool>")"
						| "function""(""takes:" <[Parameter]>, "returns:" <ValueType>")"
						| "seal""(""sealed:" <Bool>")"
				\par
				<LS.Source> ::=
						"constant""("<Int>")"
						| "named""("<Symbol>")"
						| "function""("<Label>")"
				\par
				<LS.Definition> ::=
							"("<Symbol>, <Value>")"
				\par
				<LS.Effect> ::=
						"do""("<[Effect]>")"
						| "let""("<[Definition]>, "in:" <Effect>")"
						| "setField""("<Field.Name>, "of:" <Symbol>, "to:" <Source>")"
						| "setElement""(""of:" <Symbol>, "at:" <Source>, "to:" <Source>")"
				\par
				<LS.Result> ::=
						"value""("<Value>")"
						| "evaluate""("<Source>, <[Source]>")"
						| "if""("<Predicate>, "then:" <Result>, "else:" <Result>")"
						| "let""("<[Definition]>, "in:" <Result>")"
						| "do""("<[Effect]>, "then:" <Result>")"
				\par
				<LS.RecordType> ::=
							"("<[Field]>")"
				\par
				<LS.Field> ::=
							"("<Name>, <ValueType>")"
				\par
\end{grammar}
\par
\paragraph{ DF (Definitions) } A language that introduces definitions with function-wide namespacing.
\begin{grammar}
	\footnotesize
				<DF.Program> ::=
							"("<Result>, "functions:" <[Function]>")"
				\par
				<DF.Effect> ::=
						"do""("<[Effect]>")"
						| "let""("<[Definition]>, "in:" <Effect>")"
						| "setField""("<Field.Name>, "of:" <Location>, "to:" <Source>")"
						| "setElement""(""of:" <Location>, "at:" <Source>, "to:" <Source>")"
				\par
				<DF.Result> ::=
						"value""("<Value>")"
						| "if""("<Predicate>, "then:" <Result>, "else:" <Result>")"
						| "evaluate""("<Source>, <[Source]>")"
						| "let""("<[Definition]>, "in:" <Result>")"
						| "do""("<[Effect]>, "then:" <Result>")"
				\par
				<DF.Definition> ::=
							"("<Location>, <Value>")"
				\par
				<DF.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Source>, <BranchRelation>, <Source>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "let""("<[Definition]>, "in:" <Predicate>")"
				\par
				<DF.Value> ::=
						"source""("<Source>")"
						| "binary""("<Source>, <BinaryOperator>, <Source>")"
						| "record""("<RecordType>")"
						| "field""("<Field.Name>, "of:" <Location>")"
						| "vector""("<ValueType>, "count:" <Int>")"
						| "element""(""of:" <Location>, "at:" <Source>")"
						| "seal"
						| "sealed""("<Location>, "with:" <Location>")"
						| "evaluate""("<Source>, <[Source]>")"
						| "if""("<Predicate>, "then:" <Value>, "else:" <Value>")"
						| "let""("<[Definition]>, "in:" <Value>")"
						| "do""("<[Effect]>, "then:" <Value>")"
				\par
				<DF.Function> ::=
							"("<Label>, "takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Result>")"
				\par
\end{grammar}
\par
\paragraph{ CV (Computed Values) } A language that allows a computation to be attached to a value.
\begin{grammar}
	\footnotesize
				<CV.Program> ::=
							"("<Effect>, "procedures:" <[Procedure]>")"
				\par
				<CV.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Source>, <BranchRelation>, <Source>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "do""("<[Effect]>, "then:" <Predicate>")"
				\par
				<CV.Effect> ::=
						"do""("<[Effect]>")"
						| "set""("<Location>, "to:" <Value>")"
						| "setField""("<Field.Name>, "of:" <Location>, "to:" <Source>")"
						| "setElement""(""of:" <Location>, "at:" <Source>, "to:" <Source>")"
						| "if""("<Predicate>, "then:" <Effect>, "else:" <Effect>")"
						| "return""("<Source>")"
				\par
				<CV.Procedure> ::=
							"("<Label>, "takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Effect>")"
				\par
				<CV.Value> ::=
						"source""("<Source>")"
						| "binary""("<Source>, <BinaryOperator>, <Source>")"
						| "record""("<RecordType>")"
						| "field""("<Field.Name>, "of:" <Location>")"
						| "vector""("<ValueType>, "count:" <Int>")"
						| "element""(""of:" <Location>, "at:" <Source>")"
						| "seal"
						| "sealed""("<Location>, "with:" <Location>")"
						| "evaluate""("<Source>, <[Source]>")"
						| "if""("<Predicate>, "then:" <Value>, "else:" <Value>")"
						| "do""("<[Effect]>, "then:" <Value>")"
				\par
\end{grammar}
\par
\paragraph{ CA (Canonical Assignments) } A language that groups all effects that write to a location under one canonical assignment effect.
\begin{grammar}
	\footnotesize
				<CA.Program> ::=
							"("<Effect>, "procedures:" <[Procedure]>")"
				\par
				<CA.Procedure> ::=
							"("<Label>, "takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Effect>")"
				\par
				<CA.Effect> ::=
						"do""("<[Effect]>")"
						| "set""("<Location>, "to:" <Value>")"
						| "setField""("<Field.Name>, "of:" <Location>, "to:" <Source>")"
						| "setElement""(""of:" <Location>, "at:" <Source>, "to:" <Source>")"
						| "call""("<Source>, <[Source]>, "result:" <Location>")"
						| "if""("<Predicate>, "then:" <Effect>, "else:" <Effect>")"
						| "return""("<Source>")"
				\par
				<CA.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Source>, <BranchRelation>, <Source>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "do""("<[Effect]>, "then:" <Predicate>")"
				\par
				<CA.Value> ::=
						"source""("<Source>")"
						| "binary""("<Source>, <BinaryOperator>, <Source>")"
						| "record""("<RecordType>")"
						| "field""("<Field.Name>, "of:" <Location>")"
						| "vector""("<ValueType>, "count:" <Int>")"
						| "element""(""of:" <Location>, "at:" <Source>")"
						| "seal"
						| "sealed""("<Location>, "with:" <Location>")"
				\par
\end{grammar}
\par
\paragraph{ CC (Calling Convention) } A language that introduces parameters \& result values in procedures via the low-level Glyco calling convention.
\begin{grammar}
	\footnotesize
				<CC.Program> ::=
							"("<Effect>, "procedures:" <[Procedure]>")"
				\par
				<CC.CapabilityType> ::=
						"vector""(""of:" <ValueType>, "sealed:" <Bool>")"
						| "record""("<RecordType>, "sealed:" <Bool>")"
						| "procedure""(""takes:" <[Parameter]>, "returns:" <ValueType>")"
						| "seal""(""sealed:" <Bool>")"
				\par
				<CC.RecordType> ::=
							"("<[Field]>")"
				\par
				<CC.Field> ::=
							"("<Name>, <ValueType>")"
				\par
				<CC.Parameter> ::=
							"("<Location>, <ValueType>, "sealed:" <Bool>")"
				\par
				<CC.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Source>, <BranchRelation>, <Source>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "do""("<[Effect]>, "then:" <Predicate>")"
				\par
				<CC.Source> ::=
						"constant""("<Int>")"
						| "location""("<Location>")"
						| "procedure""("<Label>")"
				\par
				<CC.Effect> ::=
						"do""("<[Effect]>")"
						| "set""("<Location>, "to:" <Source>")"
						| "compute""("<Location>, <Source>, <BinaryOperator>, <Source>")"
						| "createRecord""("<RecordType>, "capability:" <Location>, "scoped:" <Bool>")"
						| "getField""("<Field.Name>, "of:" <Location>, "to:" <Location>")"
						| "setField""("<Field.Name>, "of:" <Location>, "to:" <Source>")"
						| "createVector""("<ValueType>, "count:" <Int>, "capability:" <Location>, "scoped:" <Bool>")"
						| "getElement""(""of:" <Location>, "index:" <Source>, "to:" <Location>")"
						| "setElement""(""of:" <Location>, "index:" <Source>, "to:" <Source>")"
						| "createSeal""(""in:" <Location>")"
						| "seal""(""into:" <Location>, "source:" <Location>, "seal:" <Location>")"
						| "destroyScopedValue""(""capability:" <Source>")"
						| "if""("<Predicate>, "then:" <Effect>, "else:" <Effect>")"
						| "call""("<Source>, <[Source]>, "result:" <Location>")"
						| "return""("<Source>")"
				\par
				<CC.ValueType> ::=
						"u8"
						| "s32"
						| "cap""("<CapabilityType>")"
				\par
				<CC.Procedure> ::=
							"("<Label>, "takes:" <[Parameter]>, "returns:" <ValueType>, "in:" <Effect>")"
				\par
\end{grammar}
\par
\paragraph{ SV (Structured Values) } A language that introduces structured values, i.e., vectors and records.
\begin{grammar}
	\footnotesize
				<SV.Program> ::=
							"("<Effect>, "procedures:" <[Procedure]>")"
				\par
				<SV.ValueType> ::=
						"u8"
						| "s32"
						| "cap""("<CapabilityType>")"
						| "registerDatum"
				\par
				<SV.Source> ::=
						"constant""("<Int>")"
						| "abstract""("<AbstractLocation>")"
						| "register""("<Register>, <ValueType>")"
						| "frame""("<Frame.Location>")"
						| "capability""(""to:" <Label>")"
				\par
				<SV.Effect> ::=
						"do""("<[Effect]>")"
						| "set""("<Location>, "to:" <Source>")"
						| "compute""("<Location>, <Source>, <BinaryOperator>, <Source>")"
						| "createRecord""("<RecordType>, "capability:" <Location>, "scoped:" <Bool>")"
						| "getField""("<Field.Name>, "of:" <Location>, "to:" <Location>")"
						| "setField""("<Field.Name>, "of:" <Location>, "to:" <Source>")"
						| "createVector""("<ValueType>, "count:" <Int>, "capability:" <Location>, "scoped:" <Bool>")"
						| "getElement""(""of:" <Location>, "index:" <Source>, "to:" <Location>")"
						| "setElement""(""of:" <Location>, "index:" <Source>, "to:" <Source>")"
						| "destroyScopedValue""(""capability:" <Source>")"
						| "createSeal""(""in:" <Location>")"
						| "seal""(""into:" <Location>, "source:" <Location>, "seal:" <Location>")"
						| "if""("<Predicate>, "then:" <Effect>, "else:" <Effect>")"
						| "pushScope"
						| "popScope"
						| "clearAll""(""except:" <[Register]>")"
						| "call""("<Source>, "parameters:" <[Register]>")"
						| "callSealed""("<Source>, "data:" <Source>, "unsealedParameters:" <[Register]>")"
						| "return""(""to:" <Source>")"
				\par
				<SV.CapabilityType> ::=
						"vector""(""of:" <ValueType>, "sealed:" <Bool>")"
						| "record""("<RecordType>, "sealed:" <Bool>")"
						| "code"
						| "seal""(""sealed:" <Bool>")"
				\par
				<SV.RecordType> ::=
							"("<[Field]>")"
				\par
				<SV.Field> ::=
							"("<Name>, <ValueType>")"
				\par
				<SV.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Source>, <BranchRelation>, <Source>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "do""("<[Effect]>, "then:" <Predicate>")"
				\par
				<SV.Procedure> ::=
							"("<Label>, "in:" <Effect>")"
				\par
\end{grammar}
\par
\paragraph{ ID (Inferred Declarations) } A language that infers declarations from definitions.
\begin{grammar}
	\footnotesize
				<ID.Program> ::=
							"("<Effect>, "procedures:" <[Procedure]>")"
				\par
				<ID.Procedure> ::=
							"("<Label>, "in:" <Effect>")"
				\par
				<ID.Effect> ::=
						"do""("<[Effect]>")"
						| "set""("<Location>, "to:" <Source>")"
						| "compute""("<Location>, <Source>, <BinaryOperator>, <Source>")"
						| "createBuffer""(""bytes:" <Int>, "capability:" <Location>, "scoped:" <Bool>")"
						| "destroyBuffer""(""capability:" <Source>")"
						| "getElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Location>")"
						| "setElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Source>")"
						| "createSeal""(""in:" <Location>")"
						| "seal""(""into:" <Location>, "source:" <Location>, "seal:" <Location>")"
						| "if""("<Predicate>, "then:" <Effect>, "else:" <Effect>")"
						| "pushScope"
						| "popScope"
						| "clearAll""(""except:" <[Register]>")"
						| "call""("<Source>, "parameters:" <[Register]>")"
						| "callSealed""("<Source>, "data:" <Source>, "unsealedParameters:" <[Register]>")"
						| "return""(""to:" <Source>")"
				\par
				<ID.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Source>, <BranchRelation>, <Source>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "do""("<[Effect]>, "then:" <Predicate>")"
				\par
\end{grammar}
\par
\paragraph{ AL (Abstract Locations) } A language that introduces abstract locations, i.e., locations whose physical locations are not specified by the programmer.
\begin{grammar}
	\footnotesize
				<AL.Program> ::=
							"(""locals:" <Declarations>, "in:" <Effect>, "procedures:" <[Procedure]>")"
				\par
				<AL.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Source>, <BranchRelation>, <Source>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "do""("<[Effect]>, "then:" <Predicate>")"
				\par
				<AL.Procedure> ::=
							"("<Label>, "locals:" <Declarations>, "in:" <Effect>")"
				\par
				<AL.Effect> ::=
						"do""("<[Effect]>")"
						| "set""("<Location>, "to:" <Source>")"
						| "compute""("<Location>, <Source>, <BinaryOperator>, <Source>")"
						| "createBuffer""(""bytes:" <Int>, "capability:" <Location>, "scoped:" <Bool>")"
						| "destroyBuffer""(""capability:" <Source>")"
						| "getElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Location>")"
						| "setElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Source>")"
						| "createSeal""(""in:" <Location>")"
						| "seal""(""into:" <Location>, "source:" <Location>, "seal:" <Location>")"
						| "if""("<Predicate>, "then:" <Effect>, "else:" <Effect>")"
						| "pushScope"
						| "popScope"
						| "clearAll""(""except:" <[Register]>")"
						| "call""("<Source>, "parameters:" <[Register]>")"
						| "callSealed""("<Source>, "data:" <Source>, "unsealedParameters:" <[Register]>")"
						| "return""(""to:" <Source>")"
				\par
\end{grammar}
\par
\paragraph{ ALA (Abstract Locations, Analysed) } A language that introduces abstract locations, annotated with liveness and conflict information.
\begin{grammar}
	\footnotesize
				<ALA.Program> ::=
							"(""locals:" <Declarations>, "in:" <Effect>, "procedures:" <[Procedure]>")"
				\par
				<ALA.ConflictGraph> ::=
							"("<[Conflict]>")"
				\par
				<ALA.Conflict> ::=
							"("<Location>, <Location>")"
				\par
				<ALA.Declarations> ::=
							"("<[Declaration]>")"
				\par
				<ALA.AbstractLocation> ::=
						<String>
				\par
				<ALA.Predicate> ::=
						"constant""("<Bool>, "analysisAtEntry:" <Analysis>")"
						| "relation""("<Source>, <BranchRelation>, <Source>, "analysisAtEntry:" <Analysis>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>, "analysisAtEntry:" <Analysis>")"
						| "do""("<[Effect]>, "then:" <Predicate>, "analysisAtEntry:" <Analysis>")"
				\par
				<ALA.Source> ::=
						"constant""("<Int>")"
						| "abstract""("<AbstractLocation>")"
						| "register""("<Register>, <DataType>")"
						| "frame""("<Frame.Location>")"
						| "capability""(""to:" <Label>")"
				\par
				<ALA.Declaration> ::=
						"abstract""("<AbstractLocation>, <DataType>")"
						| "frame""("<Frame.Location>, <DataType>")"
				\par
				<ALA.Effect> ::=
						"do""("<[Effect]>, "analysisAtEntry:" <Analysis>")"
						| "set""("<Location>, "to:" <Source>, "analysisAtEntry:" <Analysis>")"
						| "compute""("<Location>, <Source>, <BinaryOperator>, <Source>, "analysisAtEntry:" <Analysis>")"
						| "createBuffer""(""bytes:" <Int>, "capability:" <Location>, "scoped:" <Bool>, "analysisAtEntry:" <Analysis>")"
						| "destroyBuffer""(""capability:" <Source>, "analysisAtEntry:" <Analysis>")"
						| "getElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Location>, "analysisAtEntry:" <Analysis>")"
						| "setElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Source>, "analysisAtEntry:" <Analysis>")"
						| "createSeal""(""in:" <Location>, "analysisAtEntry:" <Analysis>")"
						| "seal""(""into:" <Location>, "source:" <Location>, "seal:" <Location>, "analysisAtEntry:" <Analysis>")"
						| "if""("<Predicate>, "then:" <Effect>, "else:" <Effect>, "analysisAtEntry:" <Analysis>")"
						| "pushScope""(""analysisAtEntry:" <Analysis>")"
						| "popScope""(""analysisAtEntry:" <Analysis>")"
						| "clearAll""(""except:" <[Register]>, "analysisAtEntry:" <Analysis>")"
						| "call""("<Source>, "parameters:" <[Register]>, "analysisAtEntry:" <Analysis>")"
						| "callSealed""("<Source>, "data:" <Source>, "unsealedParameters:" <[Register]>, "analysisAtEntry:" <Analysis>")"
						| "return""(""to:" <Source>, "analysisAtEntry:" <Analysis>")"
				\par
				<ALA.Location> ::=
						"abstract""("<AbstractLocation>")"
						| "register""("<Register>")"
						| "frame""("<Frame.Location>")"
				\par
				<ALA.Procedure> ::=
							"("<Label>, "locals:" <Declarations>, "in:" <Effect>")"
				\par
				<ALA.Analysis> ::=
							"(""conflicts:" <ConflictGraph>, "possiblyLiveLocations:" <Set<Location>>")"
				\par
\end{grammar}
\par
\paragraph{ CD (Conditionals) } A language that introduces conditionals in effects and predicates, thereby abstracting over blocks (and jumps).
\begin{grammar}
	\footnotesize
				<CD.Program> ::=
							"("<Effect>, "procedures:" <[Procedure]>")"
				\par
				<CD.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Source>, <BranchRelation>, <Source>")"
						| "if""("<Predicate>, "then:" <Predicate>, "else:" <Predicate>")"
						| "do""("<[Effect]>, "then:" <Predicate>")"
				\par
				<CD.Effect> ::=
						"do""("<[Effect]>")"
						| "set""("<DataType>, <Location>, "to:" <Source>")"
						| "compute""("<Location>, <Source>, <BinaryOperator>, <Source>")"
						| "createBuffer""(""bytes:" <Int>, "capability:" <Location>, "onFrame:" <Bool>")"
						| "destroyBuffer""(""capability:" <Source>")"
						| "getElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Location>")"
						| "setElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Source>")"
						| "createSeal""(""in:" <Location>")"
						| "seal""(""into:" <Location>, "source:" <Location>, "seal:" <Location>")"
						| "if""("<Predicate>, "then:" <Effect>, "else:" <Effect>")"
						| "pushFrame""("<Frame>")"
						| "popFrame"
						| "clearAll""(""except:" <[Register]>")"
						| "call""("<Source>")"
						| "callSealed""("<Source>, "data:" <Source>")"
						| "return""(""to:" <Source>")"
				\par
				<CD.Procedure> ::=
							"("<Label>, "in:" <Effect>")"
				\par
\end{grammar}
\par
\paragraph{ PR (Predicates) } A language that introduces predicates in branches.
\begin{grammar}
	\footnotesize
				<PR.Program> ::=
							"("<[Block]>")"
				\par
				<PR.Block> ::=
							"(""name:" <Label>, "do:" <[Effect]>, "then:" <Continuation>")"
				\par
				<PR.Continuation> ::=
						"continue""(""to:" <Label>")"
						| "branch""(""if:" <Predicate>, "then:" <Label>, "else:" <Label>")"
						| "call""("<Source>, "returnPoint:" <Label>")"
						| "callSealed""("<Source>, "data:" <Source>, "returnPoint:" <Label>")"
						| "return""(""to:" <Source>")"
				\par
				<PR.Predicate> ::=
						"constant""("<Bool>")"
						| "relation""("<Source>, <BranchRelation>, <Source>")"
				\par
\end{grammar}
\par
\paragraph{ BB (Basic Blocks) } A language that groups effects into blocks of effects where blocks can only be entered at a single entry point and exited at a single exit point.
\begin{grammar}
	\footnotesize
				<BB.Program> ::=
							"("<[BB.Block]>")"
				\par
				<BB.Effect> ::=
						"set""("<DataType>, <Location>, "to:" <Source>")"
						| "compute""("<Location>, <Source>, <BinaryOperator>, <Source>")"
						| "createBuffer""(""bytes:" <Int>, "capability:" <Location>, "onFrame:" <Bool>")"
						| "destroyBuffer""(""capability:" <Source>")"
						| "getElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Location>")"
						| "setElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Source>")"
						| "createSeal""(""in:" <Location>")"
						| "seal""(""into:" <Location>, "source:" <Location>, "seal:" <Location>")"
						| "pushFrame""("<Frame>")"
						| "popFrame"
						| "clearAll""(""except:" <[Register]>")"
				\par
				<BB.Continuation> ::=
						"continue""(""to:" <Label>")"
						| "branch""("<Source>, <BranchRelation>, <Source>, "then:" <Label>, "else:" <Label>")"
						| "call""("<Source>, "returnPoint:" <Label>")"
						| "callSealed""("<Source>, "data:" <Source>, "returnPoint:" <Label>")"
						| "return""(""to:" <Source>")"
				\par
				<BB.Block> ::=
							"(""name:" <Label>, "do:" <[Effect]>, "then:" <Continuation>")"
				\par
\end{grammar}
\par
\paragraph{ FO (Flexible Operands) } A language that introduces flexible operands in instructions, i.e., instructions that can take frame locations in all operand positions.
\begin{grammar}
	\footnotesize
				<FO.Program> ::=
							"("<[Effect]>")"
				\par
				<FO.Source> ::=
						"constant""("<Int>")"
						| "register""("<Register>")"
						| "frame""("<Frame.Location>")"
						| "capability""(""to:" <Label>")"
				\par
				<FO.Effect> ::=
						"set""("<DataType>, <Location>, "to:" <Source>")"
						| "compute""("<Location>, <Source>, <BinaryOperator>, <Source>")"
						| "createBuffer""(""bytes:" <Int>, "capability:" <Location>, "onFrame:" <Bool>")"
						| "destroyBuffer""(""capability:" <Source>")"
						| "getElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Location>")"
						| "setElement""("<DataType>, "of:" <Location>, "offset:" <Source>, "to:" <Source>")"
						| "createSeal""(""in:" <Location>")"
						| "seal""(""into:" <Location>, "source:" <Location>, "seal:" <Location>")"
						| "pushFrame""("<Frame>")"
						| "popFrame"
						| "clearAll""(""except:" <[Register]>")"
						| "branch""(""to:" <Label>, <Source>, <BranchRelation>, <Source>")"
						| "jump""(""to:" <Label>")"
						| "call""("<Source>")"
						| "invoke""(""target:" <Source>, "data:" <Source>")"
						| "return""(""to:" <Source>")"
						| "labelled""("<Label>, <Effect>")"
				\par
				<FO.Location> ::=
						"register""("<Register>")"
						| "frame""("<Frame.Location>")"
				\par
				<FO.Register> ::=
						"zero"
						| "ra"
						| "s1"
						| "a0"
						| "a1"
						| "a2"
						| "a3"
						| "a4"
						| "a5"
						| "a6"
						| "a7"
						| "s2"
						| "s3"
						| "s4"
						| "s5"
						| "s6"
						| "s7"
						| "s8"
						| "s9"
						| "s10"
						| "s11"
						| "invocationData"
				\par
\end{grammar}
\par
\paragraph{ MM (Managed Memory) } A language that introduces a runtime, call stack, heap, and operations on them.
\begin{grammar}
	\footnotesize
				<MM.Program> ::=
							"("<[Effect]>")"
				\par
				<MM.Effect> ::=
						"copy""("<DataType>, "into:" <Register>, "from:" <Register>")"
						| "compute""(""destination:" <Register>, <Register>, <BinaryOperator>, <Source>")"
						| "load""("<DataType>, "into:" <Register>, "from:" <Frame.Location>")"
						| "store""("<DataType>, "into:" <Frame.Location>, "from:" <Register>")"
						| "createBuffer""(""bytes:" <Source>, "capability:" <Register>, "onFrame:" <Bool>")"
						| "destroyBuffer""(""capability:" <Register>")"
						| "loadElement""("<DataType>, "into:" <Register>, "buffer:" <Register>, "offset:" <Source>")"
						| "storeElement""("<DataType>, "buffer:" <Register>, "offset:" <Source>, "from:" <Register>")"
						| "deriveCapability""(""in:" <Register>, "to:" <Label>")"
						| "createSeal""(""in:" <Register>")"
						| "seal""(""into:" <Register>, "source:" <Register>, "seal:" <Register>")"
						| "pushFrame""("<Frame>")"
						| "popFrame"
						| "permit""("<[Permission]>, "destination:" <Register>, "source:" <Register>")"
						| "clearAll""(""except:" <[Register]>")"
						| "branch""(""to:" <Label>, <Register>, <BranchRelation>, <Register>")"
						| "jump""(""to:" <Target>")"
						| "call""("<Target>")"
						| "invoke""(""target:" <Register>, "data:" <Register>")"
						| "return""(""to:" <Target>")"
						| "labelled""("<Label>, <Effect>")"
				\par
				<MM.Register> ::=
						"zero"
						| "ra"
						| "s1"
						| "a0"
						| "a1"
						| "a2"
						| "a3"
						| "a4"
						| "a5"
						| "a6"
						| "a7"
						| "s2"
						| "s3"
						| "s4"
						| "s5"
						| "s6"
						| "s7"
						| "s8"
						| "s9"
						| "s10"
						| "s11"
						| "t4"
						| "t5"
						| "invocationData"
				\par
				<MM.Target> ::=
						"label""("<Label>")"
						| "register""("<Register>")"
				\par
				<MM.Source> ::=
						"constant""("<Int>")"
						| "register""("<Register>")"
				\par
				<MM.Frame> ::=
							"(""allocatedByteSize:" <Int>")"
				\par
\end{grammar}
\par
\paragraph{ RT (Runtime) } A language that introduces a runtime system and runtime routines.
\begin{grammar}
	\footnotesize
				<RT.Program> ::=
							"("<[Statement]>")"
				\par
				<RT.Effect> ::=
						"copy""("<DataType>, "into:" <Register>, "from:" <Register>")"
						\alt "compute""(""destination:" <Register>, <Register>, <BinaryOperator>, <Source>")"
						\alt "load""("<DataType>, "destination:" <Register>, "address:" <Register>, "offset:" <Int>")"
						\alt "store""("<DataType>, "address:" <Register>, "source:" <Register>, "offset:" <Int>")"
						\alt "deriveCapabilityFromPCC""(""destination:" <Register>, "upperBits:" <UInt>")"
						\alt "deriveCapabilityFromLabel""(""destination:" <Register>, "label:" <Label>")"
						\alt "offsetCapability""(""destination:" <Register>, "source:" <Register>, "offset:" <Source>")"
						\alt "getCapabilityLength""(""destination:" <Register>, "source:" <Register>")"
						\alt "setCapabilityBounds""(""destination:" <Register>, "base:" <Register>, "length:" <Source>")"
						\alt "getCapabilityAddress""(""destination:" <Register>, "source:" <Register>")"
						\alt "setCapabilityAddress""(""destination:" <Register>, "source:" <Register>, "address:" <Register>")"
						\alt "getCapabilityDistance""(""destination:" <Register>, "cs1:" <Register>, "cs2:" <Register>")"
						\alt "seal""(""destination:" <Register>, "source:" <Register>, "seal:" <Register>")"
						\alt "sealEntry""(""destination:" <Register>, "source:" <Register>")"
						\alt "permit""("<[Permission]>, "destination:" <Register>, "source:" <Register>, "using:" <Register>")"
						\alt "clear""("<[Register]>")"
						\alt "branch""(""to:" <Label>, <Register>, <BranchRelation>, <Register>")"
						\alt "jump""(""to:" <Target>, "link:" <Register>")"
						\alt "invoke""(""target:" <Register>, "data:" <Register>")"
						\alt "callRuntimeRoutine""(""capability:" <Label>, "link:" <Register>")"
				\par
				<RT.Statement> ::=
						"effect""("<Effect>")"
						| "padding""(""alignment:" <DataType>")"
						| "data""(""type:" <DataType>, "value:" <Int>, "count:" <Int>")"
						| "bssSection"
						| "labelled""("<Label>, <Statement>")"
				\par
\end{grammar}
\par
\paragraph{ CE (Canonical Effects) } A language grouping related instructions under a single effect.
\begin{grammar}
	\footnotesize
				<CE.Program> ::=
							"("<[Statement]>")"
				\par
				<CE.Statement> ::=
						"effect""("<Effect>")"
						| "padding""(""alignment:" <DataType>")"
						| "data""(""type:" <DataType>, "value:" <Int>, "count:" <Int>")"
						| "bssSection"
						| "labelled""("<Label>, <Statement>")"
				\par
				<CE.Permission> ::=
						"global"
						| "execute"
						| "load"
						| "store"
						| "loadCapability"
						| "storeCapability"
						| "storeLocalCapability"
						| "seal"
						| "invoke"
						| "unseal"
						| "setCID"
				\par
				<CE.DataType> ::=
						"u8"
						| "s32"
						| "cap"
				\par
				<CE.Source> ::=
						"constant""("<Int>")"
						| "register""("<Register>")"
				\par
				<CE.Target> ::=
						"label""("<Label>")"
						| "register""("<Register>")"
				\par
				<CE.Effect> ::=
						"copy""("<DataType>, "into:" <Register>, "from:" <Register>")"
						\alt "compute""(""destination:" <Register>, <Register>, <BinaryOperator>, <Source>")"
						\alt "load""("<DataType>, "destination:" <Register>, "address:" <Register>, "offset:" <Int>")"
						\alt "store""("<DataType>, "address:" <Register>, "source:" <Register>, "offset:" <Int>")"
						\alt "deriveCapabilityFromPCC""(""destination:" <Register>, "upperBits:" <UInt>")"
						\alt "deriveCapabilityFromLabel""(""destination:" <Register>, "label:" <Label>")"
						\alt "offsetCapability""(""destination:" <Register>, "source:" <Register>, "offset:" <Source>")"
						\alt "getCapabilityLength""(""destination:" <Register>, "source:" <Register>")"
						\alt "setCapabilityBounds""(""destination:" <Register>, "base:" <Register>, "length:" <Source>")"
						\alt "getCapabilityAddress""(""destination:" <Register>, "source:" <Register>")"
						\alt "setCapabilityAddress""(""destination:" <Register>, "source:" <Register>, "address:" <Register>")"
						\alt "getCapabilityDistance""(""destination:" <Register>, "cs1:" <Register>, "cs2:" <Register>")"
						\alt "seal""(""destination:" <Register>, "source:" <Register>, "seal:" <Register>")"
						\alt "sealEntry""(""destination:" <Register>, "source:" <Register>")"
						\alt "permit""("<[Permission]>, "destination:" <Register>, "source:" <Register>, "using:" <Register>")"
						\alt "clear""("<[Register]>")"
						\alt "branch""(""to:" <Label>, <Register>, <BranchRelation>, <Register>")"
						\alt "jump""(""to:" <Target>, "link:" <Register>")"
						\alt "invoke""(""target:" <Register>, "data:" <Register>")"
				\par
\end{grammar}
\par
\paragraph{ RV (CHERI-RISC-V) } A language that maps directly to CHERI-RISC-V assembly statements, i.e., labels, instructions, and directives.
\begin{grammar}
	\footnotesize
				<RV.Program> ::=
							"("<[Statement]>")"
				\par
				<RV.Register> ::=
						"zero"
						| "ra"
						| "sp"
						| "gp"
						| "tp"
						| "t0"
						| "t1"
						| "t2"
						| "fp"
						| "s1"
						| "a0"
						| "a1"
						| "a2"
						| "a3"
						| "a4"
						| "a5"
						| "a6"
						| "a7"
						| "s2"
						| "s3"
						| "s4"
						| "s5"
						| "s6"
						| "s7"
						| "s8"
						| "s9"
						| "s10"
						| "s11"
						| "t3"
						| "t4"
						| "t5"
						| "t6"
				\par
				<RV.Statement> ::=
						"instruction""("<Instruction>")"
						| "padding""(""byteAlignment:" <Int>")"
						| "data""(""value:" <Int>, "datumByteSize:" <Int>, "count:" <Int>")"
						| "bssSection"
						| "labelled""("<Label>, <Statement>")"
				\par
				<RV.Label> ::=
						<String>
				\par
				<RV.Instruction> ::=
						"copyWord""(""destination:" <Register>, "source:" <Register>")"
						\alt "copyCapability""(""destination:" <Register>, "source:" <Register>")"
						\alt "computeWithRegister""(""operation:" <BinaryOperator>, "rd:" <Register>, "rs1:" <Register>, "rs2:" <Register>")"
						\alt "computeWithImmediate""(""operation:" <BinaryOperator>, "rd:" <Register>, "rs1:" <Register>, "imm:" <Int>")"
						\alt "loadByte""(""destination:" <Register>, "address:" <Register>, "offset:" <Int>")"
						\alt "loadSignedWord""(""destination:" <Register>, "address:" <Register>, "offset:" <Int>")"
						\alt "loadCapability""(""destination:" <Register>, "address:" <Register>, "offset:" <Int>")"
						\alt "storeByte""(""source:" <Register>, "address:" <Register>, "offset:" <Int>")"
						\alt "storeSignedWord""(""source:" <Register>, "address:" <Register>, "offset:" <Int>")"
						\alt "storeCapability""(""source:" <Register>, "address:" <Register>, "offset:" <Int>")"
						\alt "deriveCapabilityFromLabel""(""destination:" <Register>, "label:" <Label>")"
						\alt "deriveCapabilityFromPCC""(""destination:" <Register>, "upperBits:" <UInt>")"
						\alt "offsetCapability""(""destination:" <Register>, "source:" <Register>, "offset:" <Register>")"
						\alt "offsetCapabilityWithImmediate""(""destination:" <Register>, "source:" <Register>, "offset:" <Int>")"
						\alt "getCapabilityLength""(""destination:" <Register>, "source:" <Register>")"
						\alt "setCapabilityBounds""(""destination:" <Register>, "base:" <Register>, "length:" <Register>")"
						\alt "setCapabilityBoundsWithImmediate""(""destination:" <Register>, "base:" <Register>, "length:" <Int>")"
						\alt "getCapabilityAddress""(""destination:" <Register>, "source:" <Register>")"
						\alt "setCapabilityAddress""(""destination:" <Register>, "source:" <Register>, "address:" <Register>")"
						\alt "getCapabilityDistance""(""destination:" <Register>, "cs1:" <Register>, "cs2:" <Register>")"
						\alt "seal""(""destination:" <Register>, "source:" <Register>, "seal:" <Register>")"
						\alt "sealEntry""(""destination:" <Register>, "source:" <Register>")"
						\alt "permit""(""destination:" <Register>, "source:" <Register>, "mask:" <Register>")"
						\alt "clear""(""quarter:" <Int>, "mask:" <UInt8>")"
						\alt "branch""(""rs1:" <Register>, "relation:" <BranchRelation>, "rs2:" <Register>, "target:" <Label>")"
						\alt "jump""(""target:" <Label>, "link:" <Register>")"
						\alt "jumpWithRegister""(""target:" <Register>, "link:" <Register>")"
						\alt "invoke""(""target:" <Register>, "data:" <Register>")"
				\par
				<RV.BranchRelation> ::=
						"eq"
						| "ne"
						| "lt"
						| "le"
						| "gt"
						| "ge"
				\par
				<RV.BinaryOperator> ::=
						"add"
						| "sub"
						| "mul"
						| "and"
						| "or"
						| "xor"
						| "sll"
						| "srl"
						| "sra"
				\par
\end{grammar}
\par
\paragraph{ S (CHERI-RISC-V Assembly) } The ground language as provided to Clang for assembly and linking.
\begin{grammar}
	\footnotesize
				<S.Program> ::=
							"(""assembly:" <String>")"
				\par
\end{grammar}
\par

\biblio{}
\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
