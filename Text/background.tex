\documentclass[main.tex]{subfiles}
\begin{document}
\mainmatter

\chapter{Background}

\section{Memory Safety}

Most security bugs classified as “serious” in large projects such as the Chromium browser engine are memory safety bugs, such as out-of-bounds array or call stack accesses that either arise from the use of “memory-unsafe” programming languages such as C, the use of memory safety opt-outs (such as Rust’s unsafe) in “memory-safe” programming languages, or bugs in the compiler or standard library implementation of a memory-safe programming language or runtime environment such as the Java VM or an ECMAScript interpreter.

Common approaches to mitigating attacks or restricting the attack vector that such a bug can cause include reintroducing compiler-inserted array bounds checks in memory-unsafe programming languages and enforcing page-level permissions in the virtual memory system of the operating system. However, runtime checks introduce a runtime cost, and virtual memory protection doesn’t protect against a compromised or vulnerable library such as Apache Log4j accessing potentially sensitive data in the process’ address space such as TLS session keys stored in an in-process OpenSSL data structure.

A different approach are capabilities, which are usually unforgeable pointers that carry authority over a precise region of memory and with a precise set of permissions, thereby providing fine-grained memory protection. To ensure that authority cannot be created, capabilities can only be derived from a source with more authority, such as an operating system or other privileged routine or another capability. Finally, capability support can be provided at the hardware level, removing the runtime cost associated with software-based bounds \& permission checks.

\section{Capability Hardware Enhanced RISC Instructions}
CHERI (Capability Hardware Enhanced RISC Instructions) is a design for a capability machine, extending several existing instruction set architectures (ISAs) such as RISC-V, MIPS, x86-64, and Arm with hardware capability support. One of CHERI’s design goals is to provide a viable transition path for mainstream systems. An ecosystem formed around CHERI, such as capability extensions for C \& C++, capability support in the LLVM compiler toolchain and QEMU emulator, a FreeBSD fork with capability support called CheriBSD, and several large libraries and systems such as PostgreSQL and WebKit being ported to CheriBSD.

In 64-bit CHERI-RISC-V, the CHERI extension of the RISC-V ISA, 64-bit pointers become 128-bit capabilities. Such a capability consists of a 64-bit address, a 27-bit compressed value indicating the capability’s bounds, a 16-permission bitfield (such as load/store/execute within the capability’s bounds), with the remaining 21 bits reserved for encoding other flags and the capability’s object type (used for a CHERI feature called “sealing”). A 1-bit validity tag stored out-of-band in tagged memory is set to high when the 128-bit datum represents a valid capability. The validity tag is cleared whenever the datum is modified by any instruction not intended to validly modify capabilities (such as XOR or ADD), thereby ensuring provenance and monotonicity, two safety properties that respectively require correctly deriving capabilities only from sources of authority, and prohibit arbitrarily increasing a capability’s authority.

\section{Local State Encapsulation \& Well-Bracketed Control Flow}
Capabilities are CHERI’s building blocks on which security features can be built, akin to how cryptographic primitives form the basis of cryptographic algorithms. One low-level application of capabilities is in (1) protecting a component's local state, the so-called local state encapsulation property, and (2) enforcing the return-to-callee principle, a property named well-bracketed control flow.

To illustrate the need for these two properties, let’s look at an example. Suppose Apache httpd invokes a decompression routine in libZIP, however due to a vulnerability in the libZIP routine, an attacker is able to perform a remote code execution using a maliciously crafted ZIP archive. Even if the stack capability —which replaces the stack pointer in conventional systems— is appropriately bounded to the region of memory associated with the current thread’s call stack and the called libZIP routine has no other capabilities into httpd’s data structures, the stack capability still grants the libZIP procedure (and hence the attacker) access to httpd’s stack frames and thus httpd’s local state which, of course, may include sensitive information. Alternatively, the attacker could deviate from the normal calling convention, skip the caller, and return to a caller higher up in the call stack. In order to mitigate these kinds of attacks, several “secure” calling conventions have been proposed in the literature.

One such convention, implemented by CheriBSD, consists of splitting each thread’s call stack into multiple stacks: one stack per component where all stack frames belonging to the component are stored, as well as one trusted stack in kernel memory tying all stack frames together. Each component is in its own compartmentalised security domain, and the stack capability in each component only grants access to that component’s stack memory. An attacker relying on a vulnerable component can no longer access another component’s local state this way and cannot return to an arbitrary caller. However, since it’s the kernel that manages the central cross-component stack, a system call is required to cross a security domain, i.e., to invoke a procedure in a different component.

An alternative calling convention proposed by Skorstengaard et al.\cite{retptr} avoids the need for multiple stacks and for syscalls when crossing a security domain by keeping all stack frames in a single call stack and by restricting the stack capability just before the invocation to exclude the region of stack memory containing existing stack frames. Due to the monotonicity property of capabilities, the callee cannot increase the stack capability’s authority to include the excluded region. This safety property however makes it impossible to return to the caller. For this reason, just before jumping to the callee, the caller pushes a special restoration routine onto the stack which includes the previous stack capability as its payload and whose code restores the stack capability. The callee is then provided with a return capability pointing to this routine and bounded to that routine’s memory space; the callee can return to the caller by jumping to the routine. Finally, to thwart attempts by the callee to use this return capability to read the previous stack capability, the return capability is sealed so that it can only be used to invoke the routine and not to read the routine’s code or payload.

This alternative approach as described above is alas not enough to ensure local state encapsulation and well-bracketed control flow if a compromised routine is invoked more than once. An attacker could store its stack capability somewhere during a first invocation and use that capability in a subsequent invocation. If the call stack grows by the time the attacker’s code gets to run again, the previously stored stack capability gives them authority over a larger portion of the stack than the stack capability they get in the second invocation, and thus get access to stack frames from other components.

A first solution is to prohibit writing the stack capability anywhere but on the stack itself, using a CHERI feature called local capabilities, and clearing the unused portion of the stack when returning from a procedure in a different security domain.

Clearing a region of memory is a potentially expensive operation so a second solution by Georges et al.\cite{uninitcaps} is to use a proposed CHERI feature called uninitialised capabilities which forces uninitialised memory regions to be overwritten before they can be read. In this solution, the stack capability is still a local capability as in the first solution, but the unused portion of the stack is marked as uninitialised in the stack capability, avoiding the need for clearing memory.

\end{document}