\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}}

\chapter{\acrlong*{ghscc}}
The previous chapter discussed the first milestone of the Glyco compiler, namely a nanopass compiler producing fairly traditional executables for CHERI-RISC-V targets, with almost no special considerations for capability machines, except for minor enhancements such as bounded heap-allocated buffers. This chapter discusses the first significant upgrade of the Glyco compiler, namely one where procedure calls are implemented using a secure \g{cc} named \textbf{\g{ghscc}} and adapted from the heap-based \g{cc} proposed by \cite{cerise}.

In \cref{sct:scc}, we first describe the desired security properties of a \enquote{secure} \g{cc} and list a few theoretical \gs{cc} proposed in the literature that conform to those properties. We then detail in \cref{sct:ghscc-rt} the low-level implementation of two runtime routines that form the basis of \g{ghscc}. After that, we explore in \cref{sct:ghscc} the implementation of the \g{cc} itself. We finish in \cref{sct:ghscc-eval} with an evaluation of \g{ghscc} against \g{gccc} in terms of \g{lse}, changes to the compiler and its \gs{il}, generated codesize, and runtime performance.

This chapter discusses the feature set and languages of Glyco 0.2.0,\footnote{The source code is available at \url{https://tsarouhas.eu/glyco/0.2.0/}.} however example programs in this chapter follow the grammar of the final version of the compiler, Glyco 1.0.0. A full language reference of this final compiler can be found in \cref{ch:grammar}.

\section{Background: Secure Calling Conventions} \label{sct:scc}
A traditional \g{cc} such as \g{gccc} works with a single stack of call frames per thread, with each call frame holding a procedure call's ephemeral state, such as values assigned to local variables. When a procedure is called, a new call frame is pushed on the stack, the caller puts a return address in a designated register or location on the call frame, and passes control to the callee. When returning, the most recent call frame on the stack is popped and the callee jumps to the caller-provided return address. The exact details and distribution of responsibilities are mandated by the \g{cc} in use.

A traditional \g{cc} however provides no security in the face of adversarial code that operates in the same address space. For one, adversarial code has access to the full call stack and thus to other call frames than its own. The adversarial code may be from an external dependency that hasn't been rigorously vetted, but it may also be first-party code containing an overflow vulnerability on a statically-allocated buffer that is exploited with specially crafted input, as illustrated in \cref{fig:buffoverflow}. \textbf{\Gls{lse}} is a security property that makes it impossible for a procedure to access the local state, i.e., call frame, of another procedure, or for a procedure in one compartment (such as a library) to access the local state of a procedure in another compartment.

\begin{figure}
	\begin{center}
		\includegraphics{Images/Buffer Overflow.pdf}
	\end{center}
	\caption{A vulnerability in a (trusted) libWeakZIP procedure may allow an attacker to overflow the stack-allocated buffer. In this example, the return address is stored at the end of the caller's call frame and is thus overwritten by the attack. Note that the stack grows downward.}
	\label{fig:buffoverflow}
\end{figure}

A different but related problem is that adversarial code may ignore the \g{retcap} provided by the caller and instead return to a different location within the caller. They may, for instance, skip an authentication check by jumping straight into the execution path of a successful authentication. They may also store the provided \g{retcap} and jump to it more than once. In contrast, when \textbf{\g{wbcf}} applies, a procedure can either return to the caller, call other procedures, or diverge (e.g., get stuck in an infinite loop).

\subsection*{Proposed Solutions} \todo{Move alternative \gs{cc} to a separate \emph{Related Work} section or chapter near conclusion.}
To ensure \g{lse}, a caller can restrict the stack capability before calling a procedure so that the callee only gets access to the unused part of the stack. However, as illustrated in \cref{fig:savedstackcap}, an adversary can save a copy of their (restricted) stack capability in a first call. If the adversary is called a second time when their stack capability is lower in the stack (due to the stack containing more call frames than during the first call), it can use the saved stack capability to gain access to memory used by other call frames. Several solutions have been proposed to this problem, as well as for ensuring \g{wbcf}.

\begin{figure}
	\begin{center}
		\includegraphics{Images/Saved Stack Cap.pdf}
	\end{center}
	\caption{The call stack in a first invocation (left) and a second invocation (right) of the adversary, where the second invocation's call frame is at a lower address than the first invocation's call frame. During the first invocation, the adversary saves their stack capability for use during a later invocation. Even though the stack capability in the second invocation provides authority over a smaller part of the call stack, the previously saved stack capability continues to provide the adversary with authority over the larger region, which now includes memory occupied by other call frames. Note that the stack grows downward.}
	\label{fig:savedstackcap}
\end{figure}

\paragraph{Using one call stack per compartment} As described in \cite{compartment}, CheriBSD supports compartmentalising software components (such as libraries) whereby each component gets its own call stack, with the operating system managing a central stack per thread. This approach however requires one call stack per component per thread, one central stack per thread, and one syscall per security domain transition, i.e., when a compartment's procedure calls or returns into another compartment's procedure. Furthermore, it does not provide complete \g{lse} since it only protects components from other components; a vulnerability in a procedure within a library may compromise all call frames from that library in the same thread. Finally, since returns across components are mediated by the OS, \g{wbcf} across components can be enforced by the system itself.

\paragraph{Using local capabilities to revoke copies of the stack capability} A calling convention proposed by \cite{retptr} relies on local capabilities, a type of capability that can be only kept in registers and stored using capabilities that allow storing local capabilities. Local capabilities in CHERI are capabilities without the \emph{Global} permission, whereas capabilities that can be used to store local capabilities have the \emph{Store local capability} permission.

Just before a procedure is called, the caller pushes a restoration routine\footnote{\cite{retptr} uses the term \emph{activation record} instead, but since it's also a synonym for \emph{call frame}, we decided against reusing this terminology in this thesis.} on the call stack, sets the \g{retcap} to point to that restoration routine, and seals it as a \g{sentry}. The restoration routine restores the caller's stack capability and returns to the caller; the saved stack and return capabilities used by the routine are therein embedded.

To prevent the callee from saving their return and stack capabilities somewhere, the return and stack capabilities are marked as local. However, the two capabilities still need to be saved in the restoration routine. Since this routine is part of the call stack, the stack capability is given the \emph{Store local capability} permission. This permission is not given to capabilities to any other region of memory, ensuring that return and stack capabilities can't be saved elsewhere. Since the adversary can still save these capabilities somewhere in stack memory, e.g., far from any call frames where it's unlikely to be overwritten, the stack must be cleared before calling or returning to a possible adversary.

The calling convention guarantees both \g{lse} and \g{wbcf} since an adversary cannot retain either a stack or return capability after it returns. However, it requires clearing of potentially large regions of stack memory which is inefficient if no hardware support is available. Furthermore, since the call stack needs to hold executable restoration routines, the stack capability needs the \emph{Permit execute} permission, for which special care must be taken to avoid accidentally executing code stored in input buffers.

\paragraph{Using local uninitialised capabilities to revoke copies of the stack capability} A calling convention proposed by \cite{uninitcapss,uninitcaps} builds on the aforementioned calling convention but removes the requirement for stack clearing. It instead relies on uninitialised capabilities, a type of capability proposed by \cite{uninitcapss} only allowing loads on an initialised part of its bounds. Storing a datum immediately after the initialised region extends the capability's initialised region to include the newly stored datum. A large region of memory can be marked as uninitialised, effectively making them inaccessible unless overwritten. Uninitialised capabilities are however as of writing not specified for CHERI-RISC-V.

\paragraph{Using linear capabilities to restrict copies of the stack capability} The \emph{StkTokens} calling convention by \cite{stktokens} relies on linear capabilities, a type of capability that can only be moved, not copied. Before calling a procedure, the caller performs a splitting operation which splits the stack capability into two disjoint capabilities. The stack capability over the caller's call frame as well as the callee's \g{retcap} are sealed together with a unique \g{sealcap}. The caller then hands the sealed pair as well as the second (still unsealed) stack capability over to the callee.

The callee returns control to the caller by passing the unsealed stack capability to the caller (e.g., via a dedicated register) and invoking the sealed stack–return capability pair. The machine unseals both capabilities and jumps to the caller. The caller merges the two stack capabilities back to get its original stack capability, over both its call frame and the unused part of the stack.

\G{lse} is guaranteed by the stack capability's linearity: the callee must yield its unsealed stack capability to the caller before the caller can reconstruct its previous stack capability. In addition, the callee only gets a sealed stack capability to the caller's call frame, assuming the caller uses a unique \g{sealcap} that it doesn't hand to the callee. \G{wbcf} is also guaranteed by the stack capability's linearity since the callee can only return to the caller by invoking the stack–return capability pair whereas the callee loses access to that stack capability when they return the first time. 

Although this calling convention is delightfully straightforward in its design, linear capabilities are as of writing not specified for CHERI-RISC-V.

\paragraph{Safely heap-allocating call frames} A calling convention proposed by \cite[section~7.3]{cerise} sidesteps the stack capability revocation problem altogether by ensuring that call frames always occupy freshly allocated memory to which certainly no dangling capabilities point. \g{ghscc} adapts a variant of this calling convention.

\section{Secure Heap Allocation \& A Runtime} \label{sct:ghscc-rt}
As the name suggests, \acrlong{ghscc} uses the heap instead of a call stack. A secure implementation of \g{ghscc} depends on a secure implementation of heap allocation as described in \cite[section~7.1]{cerise}: a region of memory belonging to a heap-allocated buffer must only be accessible to \gs{userp} via the capability provided by the allocator when that buffer is allocated.

Glyco implements a simple \emph{bump-pointer} allocator where an allocation is performed by returning an appropriately bounded capability to the first free region in heap memory and offsetting an internal \textbf{heap capability} to point to the next free location after the allocated buffer. Deallocation is not supported; the allocator therefore never returns a capability to a region of memory used by a previously allocated buffer.\footnote{As described in \cite[section~2.3.16]{cheri}, capability revocation in a garbage-collected system can be implemented in several ways such as scanning accessible memory to revoke dangling capabilities, or having the memory management unit prevent accesses to deallocated buffers. Revocation and garbage collection are outside this thesis' scope.}

To implement heap allocation and future functionality securely, Glyco is extended with support for \gs{rtrt}, which are procedures provided by the language \g{rt}, with capabilities not afforded to normal procedures, and possibly using a different (often more basic) \g{cc} than ordinary procedures. Each \g{rtrt} is stored in memory not directly accessible to \gs{userp} except via a \g{sentry} to the routine's entry point, as can be seen in \cref{fig:procmem}.

\begin{figure}
	\begin{center}
		\includegraphics{Images/GHSCC Process Memory.pdf}
	\end{center}
	\caption{The process memory layout of a program compiled with \g{ghscc}. The allocation routine contains a heap capability that grants access to the heap and points to the next allocatable location in it. The secure calling routine embeds a \g{sealcap} which it uses to seal the \texttt{cra}–\texttt{cfp} pair for callees. Both routines are accessible to the \g{userp} only via a \g{sentry}.}
	\label{fig:procmem}
\end{figure}

As Glyco is developed almost entirely in isolation, it cannot rely on an operating system or dynamic linker to provide these routines and therefore provides them itself. It is expected that a production compiler would be able to rely on an OS-provided standard library instead, thereby removing the need to trust the compiler and its \g{rt}.

The first \g{rtrt} is a \textbf{heap allocation routine}, which accepts a byte size in \texttt{t0} and a return capability in \texttt{ct2} and returns a unique capability to an allocated buffer in \texttt{ct1}. The heap capability, providing access to the full heap and pointing to the next free location, is stored within the allocator's memory. This ensures that, at any point in time, only the allocator has access to unallocated memory and that memory associated with an allocated buffer is only ever accessible to the allocator and whoever holds the capability to that buffer returned by the allocator.

\section{Call Frame Encapsulation \& Secure Calling} \label{sct:ghscc}
A procedure allocates a buffer for its call frame in its prologue by calling the heap allocation routine with an appropriate byte size, and uses the call frame just as it would with \g{gccc}. The heap allocation routine ensures that only it and the procedure have access to the buffer,\footnote{The \g{rt} is implicitly trusted in our threat model. In a realistic compiler and runtime environment with a heap allocation routine, the program would need to trust at least the dynamic linker and any linked runtime code.} thereby ensuring that \g{lse} holds at that point in time.

A procedure call in \g{ghscc} is realised using a \textbf{secure calling (s-call) routine} and is therefore referred to as an \textbf{\g{scall}}. This \g{rtrt} expects a target capability in \texttt{ct6}, a \g{retcap} in \texttt{cra}, and a \g{framecap} in \texttt{cfp}. When invoked, the routine generates a unique \g{sealcap}, seals the frame and return capabilities, and jumps to the target capability's address. Similar to how the heap capability in the allocation routine grants the latter access to the heap and points to the next free location, the \g{scall} routine contains a \g{sealcap} that grants it \g{sealing} power for all \gs{otype} and whose address is the next available \g{otype}. An \g{scall} looks as follows:

\begin{enumerate}
	
	\item Just as with \g{gccc}, the caller puts the arguments for the callee in argument registers. However, if there are more parameters than there are argument registers, an arguments record is allocated on the heap (using the \g{rtrt} described above), a capability to it is put in the last argument register, and any arguments that don't fit in registers are stored in the arguments record. The callee never needs to access the caller's call frame to gain access to arguments that didn't fit in registers.
	
	\item \label{itm:retseal} The caller creates a unique \g{sealcap} and stores it in its call frame. This capability is itself unsealed and will be used to ensure that the callee can only return to the caller once.\footnote{This step is not part of Glyco 0.2.0 but instead added in a later version.}
	
	\item The caller clears all registers except those used for the \g{framecap} and for arguments. This ensures that the callee doesn't accidentally receive any authority beyond what is explicitly passed to it.
	
	\item The caller invokes the \g{scall} routine, passing to it a target capability to the caller and a \g{retcap} to itself. The routine also receives the caller's \g{framecap} via \texttt{cfp}.
	
	\item The routine seals the received \g{framecap} and \g{retcap} with its \g{sealcap}, then increases the \g{sealcap}'s address to ensure that the next \g{scall} is sealed with a unique \g{otype}.
	
	\item The routine clears any registers that it has used itself to ensure it doesn't accidentally leak new authority, then jumps to the target capability's address (the callee).
	
	\item The callee starts executing where it first allocates a call frame using the heap allocation routine and stores the caller's (sealed) \g{framecap} in it.
	
	\item When the callee is done, it clears all registers except those used for the result and the \g{retcap}. This ensures that the caller doesn't accidentally receive any authority beyond what is explicitly returned to it.
	
	\item The callee returns control to the caller with \hbox{\texttt{cinvoke cra, cfp}} where \texttt{cra} and \texttt{cfp} are the \g{retcap} resp. \g{framecap} provided to the callee by the \g{scall} routine. The machine unseals the two capabilities after checking that they have the same \g{otype}, then puts the second operand (\texttt{cfp}) in \texttt{ct6}, and finally jumps to the first operand's address (\texttt{cra}).
	
	\item The caller restores its \g{framecap} by moving the capability in \texttt{ct6} back to \texttt{cfp}.
	
	\item The caller seals the \g{sealcap} from Step~\ref{itm:retseal} using the \g{sealcap} itself, replacing the previous copy in the call frame.\footnotemark[\value{footnote}] A sealed capability cannot be sealed again nor can a sealed \g{sealcap} be used to seal a capability, which causes this step to fail if the callee attempts to use the \g{retcap} a second time for the same \g{scall}.
	
	\item The caller resumes execution.
	
\end{enumerate}

As part of an \g{scall}, the callee receives arguments and a return–frame capability pair sealed with a unique \g{otype} for which the callee has no \g{unsealcap} and therefore cannot dereference. The callee thus cannot access the caller's local state, thereby preserving \g{lse}. The capabilities are only unsealed when control is returned to the caller using the atomic \texttt{CInvoke} instruction. Since the callee also doesn't have a \g{sealcap} for that \g{otype}, it cannot forge a call stack to manipulate the procedure's local state, nor can it forge a \g{retcap} to trick \texttt{CInvoke} into unsealing the sealed \g{framecap} before invoking adversarial code.

Before invoking the \g{scall} routine, the caller creates a \g{sealcap} and stores it in its call frame. When the callee returns control to the caller, the caller attempts to seal this \g{sealcap}. This operation succeeds the first time but fails if repeated since \g{sealing} an already sealed capability causes a machine trap. This ensures that a \g{retcap} associated with a specific \g{scall} can be used at most once and thus preserves \g{wbcf}. Since \g{lse} protects the call frame from external access, it also protects the \g{sealcap} from the same.

\section{Changes to Glyco} \label{sct:ghscc-changes}
% TODO

\paragraph{CHERI-RISC-V (RV)} The ground language is extended with additional grammar for statements such as \texttt{padding} and \texttt{bssSection}, which can be \glslink{lowering}{lowered} trivially to their CHERI-RISC-V assembly counterparts. Instructions are now merely one kind of statement, and programs are redefined as a list of statements. This additional grammar is required by MM which now explicitly manages regions of memory for use by the call stack, the heap, or \gs{rtrt}.

\paragraph{Canonical Effects (CE)} To avoid overloading MM's \g{nanopass} with responsibilities, a new \g{il} is defined above RV grouping related instructions. Instructions such as \texttt{copyWord} and \texttt{copyCapability} are for instance exposed under a single \texttt{copy} effect in CE, which MM inherits.

\paragraph{Runtime (RT)} To facilitate calling \gs{rtrt} (which behave differently than ordinary procedures), a new \g{il} is defined above CE providing a \texttt{callRuntimeRoutine} effect. This effect accepts a label to a capability located in memory accessible to the \g{userp}, loads the capability, and jumps to its address. These capabilities are \gs{sentry} to \g{rt} memory; \gs{userp} cannot dereference these capabilities but they can jump to their address. This prevents a \g{userp} from accessing the \g{rt}'s internal data structures like the heap.

\paragraph{Managed Memory (MM)} MM moves above RT but its grammar remains mostly the same as in the previous version. Its \g{nanopass} however changes significantly. When a \texttt{Program} is lowered, MM now includes runtime initialisation code, explicit ELF sections for the call stack and heap, and a \g{sentry} to the allocation \g{rtrt}. The \g{lowering} of the \texttt{createBuffer} effect is updated to invoke the allocation routine instead of directly manipulating the heap capability (previously kept in register \texttt{ctp}).

% TODO

\section{Evaluation} \label{sct:ghscc-eval}
% TODO

\biblio{}
\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
