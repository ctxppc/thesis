\documentclass[main.tex]{subfiles}
\begin{document}
\onlyinsubfile{\mainmatter{}}

\chapter{Glyco Heap-based Secure Calling Convention}
The previous chapter discussed the first milestone of the Glyco compiler, namely a nanopass compiler producing fairly traditional executables for CHERI-RISC-V targets, with almost no special considerations for capability machines, except for minor enhancements such as bounded heap-allocated buffers. This chapter discusses the first significant upgrade of the Glyco compiler, namely one where procedure calls are implemented using a secure \cc{} named \textbf{\gls{ghscc}} and adapted from the heap-based \cc{} proposed by \cite{cerise}.

We begin this chapter by describing the desired security properties of a \enquote{secure} \cc{} and listing some theoretical \ccs{} proposed in the literature that have those properties. We then describe the implementation of two runtime routines that form the basis of \gls{ghscc}, and how they interact with the new \cc{}. We finish with an evaluation of \gls{ghscc} against \gls{gccc} in terms of \gls{lse}, changes to the compiler and its \ils{}, generated codesize, and runtime performance.

\section{Background: Secure Calling Conventions}
A traditional \cc{} such as \gls{gccc} works with a single stack of call frames per thread, with each call frame holding a procedure call's ephemeral state, such as values assigned to local variables. When a procedure is called, a new call frame is pushed on the stack, the caller puts a return address in a designated register or location on the call frame, and passes control to the callee. When returning, the most recent call frame on the stack is popped and the callee jumps to the caller-provided return address. The exact details and distribution of responsibilities are mandated by the \cc{} in use.

A traditional \cc{} however provides no security in the face of adversarial code that operates in the same address space. For one, adversarial code has access to the full call stack and thus to other call frames than its own. The adversarial code may be from an external dependency that hasn't been rigorously vetted, but it may also be first-party code containing an overflow vulnerability on a statically-allocated buffer that is exploited with specially crafted input, as illustrated in \cref{fig:buffoverflow}. \textbf{\Gls{lse}} is a security property that makes it impossible for a procedure to access the local state, i.e., call frame, of another procedure, or for a procedure in one compartment (such as a library) to access the local state of a procedure in another compartment.

\begin{figure}
	\begin{center}
		\includegraphics{Images/Buffer Overflow.pdf}
	\end{center}
	\caption{A vulnerability in a (trusted) libWeakZIP procedure may allow an attacker to overflow the stack-allocated buffer. In this example, the return address is stored at the end of the caller's call frame and is thus overwritten by the attack. Note that the stack grows downward.}
	\label{fig:buffoverflow}
\end{figure}

A different but related problem is that adversarial code may ignore the \gls{retcap} provided by the caller and return to a different location within the caller. They may, for instance, skip an authentication check by jumping straight into the execution path of a successful authentication. They may also store the provided \gls{retcap} and jump to it more than once. In contrast, when \textbf{\gls{wbcf}} applies, a procedure can either return to the caller, call other procedures, or diverge (e.g., get stuck in an infinite loop).

\subsection*{Proposed Solutions}
To ensure \gls{lse}, a caller can restrict the stack capability before calling a procedure so that the callee only gets access to the unused part of the stack. However, as illustrated in \cref{fig:savedstackcap}, an adversary can save a copy of their (restricted) stack capability in a first call. If the adversary is called a second time when their stack capability is lower in the stack (due to the stack containing more call frames than during the first call), it can use the saved stack capability to gain access to memory used by other call frames. Several solutions have been proposed to this problem, as well as for ensuring \gls{wbcf}.

\begin{figure}
	\begin{center}
		\includegraphics{Images/Saved Stack Cap.pdf}
	\end{center}
	\caption{The call stack in a first invocation (left) and a second invocation (right) of the adversary. During the first invocation, the adversary saves their stack capability for use during a later invocation. Even though the stack capability in the second invocation provides authority over a smaller part of the call stack, the previously saved stack capability continues to provide the adversary with authority over the larger region, which now includes memory occupied by other call frames. Note that the stack grows downward.}
	\label{fig:savedstackcap}
\end{figure}

\paragraph{Using one call stack per compartment} As described in \cite{compartment}, CheriBSD supports compartmentalising software components (such as libraries) whereby each component gets its own call stack, with the operating system managing a central stack per thread. This approach however requires one call stack per component per thread, one central stack per thread, and one syscall per security domain transition, i.e., when a compartment's procedure calls or returns into another compartment's procedure. Furthermore, it does not provide complete \gls{lse} since it only protects components from other components; a vulnerability in a procedure within a library may compromise all call frames from that library in the same thread. Finally, since returns across components are mediated by the OS, \gls{wbcf} across components can be enforced by the system itself.

\paragraph{Using local capabilities to revoke copies of the stack capability} A calling convention proposed by \cite{retptr} relies on local capabilities, a type of capability that can be only kept in registers and stored using capabilities that allow storing local capabilities. Local capabilities in CHERI are capabilities without the \emph{Global} permission, whereas capabilities that can be used to store local capabilities have the \emph{Store local capability} permission.

Just before a procedure is called, the caller pushes a restoration routine\footnote{\cite{retptr} uses the term \emph{activation record} instead, but since it's also a synonym for \emph{call frame}, we decided against reusing this terminology in this thesis.} on the call stack, sets the \g{retcap} to point to that restoration routine, and seals it as a \gls{sentry}. The restoration routine restores the caller's stack capability and returns to the caller; the saved stack and return capabilities used by the routine are therein embedded.

To prevent the callee from saving their return and stack capabilities somewhere, the return and stack capabilities are marked as local. However, the two capabilities still need to be saved in the restoration routine. Since this routine is part of the call stack, the stack capability is given the \emph{Store local capability} permission. This permission is not given to capabilities to any other region of memory, ensuring that return and stack capabilities can't be saved elsewhere. Since the adversary can still save these capabilities somewhere in stack memory, e.g., far from any call frames where it's unlikely to be overwritten, the stack must be cleared before calling or returning to a possible adversary.

The calling convention guarantees both \g{lse} and \g{wbcf} since an adversary cannot retain either a stack or return capability after it returns. However, it requires clearing of potentially large regions of stack memory which is inefficient if no hardware support is available. Furthermore, since the call stack needs to hold executable restoration routines, the stack capability needs the \emph{Permit execute} permission, for which special care must be taken to avoid accidentally executing code stored in input buffers.

\paragraph{Using local uninitialised capabilities to revoke copies of the stack capability} A calling convention proposed by \cite{uninitcapss,uninitcaps} builds on the aforementioned calling convention but removes the requirement for stack clearing. It instead relies on uninitialised capabilities, a type of capability proposed by \cite{uninitcapss} only allowing loads on an initialised part of its bounds. Storing a datum immediately after the initialised region extends the capability's initialised region to include the newly stored datum. A large region of memory can be marked as uninitialised, effectively making them inaccessible unless overwritten. Uninitialised capabilities are however as of writing not specified for CHERI-RISC-V.

\paragraph{Using linear capabilities to restrict copies of the stack capability} The \emph{StkTokens} calling convention by \cite{stktokens} relies on linear capabilities, a type of capability that can only be moved, not copied. Before calling a procedure, the caller performs a splitting operation which splits the stack capability into two disjoint capabilities. The stack capability over the caller's call frame as well as the callee's \g{retcap} are sealed together with a unique \g{sealcap}. The caller then hands the sealed pair as well as the second (still unsealed) stack capability over to the callee.

The callee returns control to the caller by passing the unsealed stack capability to the caller (e.g., via a dedicated register) and invoking the sealed stackâ€“return capability pair. The machine unseals both capabilities and jumps to the caller. The caller merges the two stack capabilities back to get its original stack capability, over both its call frame and the unused part of the stack.

\G{lse} is guaranteed by the stack capability's linearity: the callee must yield its unsealed stack capability to the caller before the caller can reconstruct its previous stack capability. In addition, the callee only gets a sealed stack capability to the caller's call frame, assuming the caller uses a unique \g{sealcap} that it doesn't hand to the callee. \G{wbcf} is also guaranteed by the stack capability's linearity since the callee can only return to the caller by invoking the stackâ€“return capability pair whereas the callee loses access to that stack capability when they return the first time. 

Although this calling convention is delightfully straightforward in its design, linear capabilities are as of writing not specified for CHERI-RISC-V.

\paragraph{Safely heap-allocating call frames} A calling convention proposed by \cite[section~7.3]{cerise} sidesteps the stack capability revocation problem altogether by ensuring that call frames always occupy freshly allocated memory to which certainly no dangling capabilities point. \gls{ghscc} adapts a variant of this calling convention.

\section{Secure Heap Allocation \& A Runtime}
As the name suggests, \acrlong{ghscc} uses the heap instead of a call stack. A secure implementation of \gls{ghscc} depends on a secure implementation of heap allocation as described in \cite[section~7.1]{cerise}: a region of memory belonging to a heap-allocated buffer must only be accessible to \gs{userp} via the capability provided by the allocator when that buffer is allocated.

Glyco implements a simple \emph{bump-pointer} allocator where an allocation is performed by returning an appropriately bounded capability to the first free region in heap memory and offsetting an internal heap capability to point to the next free location after the allocated buffer. Deallocation is not supported; the allocator therefore never returns a capability to a region of memory used by a previously allocated buffer.\footnote{As described in \cite[section~2.3.16]{cheri}, capability revocation in a garbage-collected system can be implemented in several ways such as scanning accessible memory to revoke dangling capabilities, or having the memory management unit prevent accesses to deallocated buffers. Revocation and garbage collection are outside this thesis' scope.} The allocation routine's memory, which comprises its code and the heap capability, is not accessible to \gs{userp} except via a \gls{sentry} to the routine's entry point. This ensures that, at any point in time, only the allocator has access to unallocated memory and that memory associated with an allocated buffer is only ever accessible to the allocator and whoever holds the capability to that buffer returned by the allocator.

To implement the routine securely, Glyco is first extended with support for \glspl{rtrt}, which are procedures provided by the language \gls{rt}, with capabilities not afforded to normal procedures, and possibly using a different (often more basic) \g{cc} than ordinary procedures. As Glyco is developed almost entirely in isolation, it cannot rely on an operating system or dynamic linker to provide these routines and therefore provides them itself. It is expected that a production compiler would be able to rely on an OS-provided standard library instead, thereby removing the need to trust the compiler and its \g{rt}.

% TODO: Move changes to ILs to separate section after conceptual explanation of alloc & scall and describe all changes in one go

\paragraph{CHERI-RISC-V (RV)} The ground language is extended with additional grammar for statements such as \texttt{padding} and \texttt{bssSection}, which can be \glslink{lowering}{lowered} trivially to their CHERI-RISC-V assembly counterparts. Instructions are now merely one kind of statement, and programs are redefined as a list of statements. This additional grammar is required by MM which now explicitly manages regions of memory for use by the call stack, the heap, or \gs{rtrt}.

\paragraph{Canonical Effects (CE)} To avoid overloading MM's \g{nanopass} with responsibilities, a new \g{il} is defined above RV grouping related instructions. Instructions such as \texttt{copyWord} and \texttt{copyCapability} are for instance exposed under a single \texttt{copy} effect in CE, which MM inherits.

\paragraph{Runtime (RT)} To facilitate calling \gs{rtrt} (which behave differently than ordinary procedures), a new \g{il} is defined above CE providing a \texttt{callRuntimeRoutine} effect. This effect accepts a label to a capability located in memory accessible to the \g{userp}, loads the capability, and jumps to its address. These capabilities are \gs{sentry} to \g{rt} memory; \gs{userp} cannot dereference these capabilities but they can jump to their address. This prevents a \g{userp} from accessing the \g{rt}'s internal data structures like the heap.

\paragraph{Managed Memory (MM)} MM moves above RT but its grammar remains mostly the same as in the previous version. Its \g{nanopass} however changes significantly. When a \texttt{Program} is lowered, MM now includes runtime initialisation code, explicit ELF sections for the call stack and heap, and a \g{sentry} to the allocation \g{rtrt}. The \g{lowering} of the \texttt{createBuffer} effect is updated to invoke the allocation routine instead of directly manipulating the heap capability (previously kept in register \texttt{ctp}).

% TODO

\section{Secure Calling}
% TODO

\section{Evaluation}
% TODO

\biblio{}
\onlyinsubfile{\glsaddall\printglossaries}
\end{document}
